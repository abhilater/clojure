<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Clojure by mbonaci</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Clojure</h1>
        <h2>(Now former) Java developer sneaks up on Clojure</h2>
        <a href="https://github.com/mbonaci/clojure" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <p><em>Written in January 2014, with Clojure 1.5.1 and Leiningen 2.3.4 on Java 1.7.0_45.</em><br>
<em>Inspired by Aphyr's excellent, Clojure from-the-ground-up tutorial and made possible by "The joy of Clojure" book. I also heavily used great "Clojure for Java programmers" talks by Rich Hickey, father of Clojure.</em>  </p>

<p><em>Inspired? Made possible? Who am I kidding, I flat out stole from those kind people.</em></p>

<h2>
<a id="clojure-thats-a-lisp-for-gods-sake" class="anchor" href="#clojure-thats-a-lisp-for-gods-sake" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clojure? That's a Lisp, for god's sake!</h2>

<p>I've been avoiding Clojure for a <em>long time</em>. Because it's a <em>Lisp dialect</em> and I have a negative Lisp experience from school. It was either a bad timing or a bad teacher, I guess.<br>
Hmm, I guess my guessing about it, in itself, implies the answer :) </p>

<blockquote>
<p>Times and times again it gets apparent to me. Late puberty and adolescence are not the right times to go wide with programming languages!</p>
</blockquote>

<h1>
<a id="" class="anchor" href="#" aria-hidden="true"><span class="octicon octicon-link"></span></a>:)</h1>

<h3>
<a id="it-must-had-something-to-do-with-the-way-the-book-was-written" class="anchor" href="#it-must-had-something-to-do-with-the-way-the-book-was-written" aria-hidden="true"><span class="octicon octicon-link"></span></a>It must had something to do with the way the book was written</h3>

<p>My renewed interest in Clojure was due to a chance encounter. I stumbled upon Aphyr's (Kyle Kingsbury) fascinating <a href="http://aphyr.com/tags/jepsen">Jepsen series</a>, a blog about perils of uncertainty in distributed systems.  </p>

<p>There, Clojure looked terse and concise, yet expressive and simple. So I decided to give it a shot. I picked up <a href="http://joyofclojure.com">The joy of Clojure</a>, got in my sweatshirt, put on a headband, closed my wife and our two-month-old twins in the living room, slightly licked my finger and opened up the first page...</p>

<blockquote>
<p>After the initial discovery phase, as I was going through the book, I suddenly found myself infatuated with the language. It's beautifully uniform, consistent and simple (which is different from "easy", mind you). At that point, it has just spread out to me, ready to be gulped away. And that's a great feeling!</p>
</blockquote>

<h3>
<a id="how-would-you-describe-clojure" class="anchor" href="#how-would-you-describe-clojure" aria-hidden="true"><span class="octicon octicon-link"></span></a>How would you describe Clojure?</h3>

<p>Clojure prides itself in being a <strong>dynamic functional programming language</strong>.<br>
It is built on three great facilities, <strong>immutable data, first-class functions and dynamic typing</strong>.  </p>

<p><strong>Immutable data</strong> means that a function always produces the same output, given the same input and that functions are side-effects free (when a function is run, nothing changes outside that function). All collections are immutable by design. Immutability in Clojure is not optional, like for instance, in Scala.</p>

<p><strong>First class functions</strong> means that a variable can be bound to a function, that a function can be passed to another (higher-order) function or that it may be returned from a function. In short, function is data.</p>

<p><strong>Dynamic typing</strong> means that we don't declare types. Data types are resolved at runtime.</p>

<blockquote>
<p>So from now on, when we say "modify", "add", "remove", ... it really means - create a "copy", modify the copy and return a reference to that new object.
But the word "copy" from the previous sentence doesn't stand for a full, brute-force copy. In order to provide immutability and still preserve the performance guarantees (big O notation), Clojure uses something called <strong>Structural sharing</strong>, which basically means that the data structure of the new object is built by creating references to the elements of the old object, varying only with respect to the modified elements (called <strong>path copying</strong>). </p>

<p>To picture this, think of a tree that gets a new node. Nodes of the new tree simply point to nodes of the old tree, so that, consequently, only a single full-blown node object gets created.</p>
</blockquote>

<h1>
<a id="set-the-fuck-up" class="anchor" href="#set-the-fuck-up" aria-hidden="true"><span class="octicon octicon-link"></span></a>Set the fuck up!</h1>

<h3>
<a id="and-gimme-prs" class="anchor" href="#and-gimme-prs" aria-hidden="true"><span class="octicon octicon-link"></span></a>And gimme PRs</h3>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/lein.jpg" alt="Leiningen logo" title="The man himself" align="right"></p>

<blockquote>
<p>Disclaimer: I write this as I'm going through the book myself, so bear with me. Open pull requests as you see fit</p>
</blockquote>

<p>OK, that's more than enough BS (for now). Let's start by setting up our Clojure runtime environment.</p>

<p>To set it up, I suggest you use an excellent automation tool (dependency mgr, builder, test runner, packager, all-in-one) <a href="http://leiningen.org/">Leiningen</a>. </p>

<blockquote>
<p>Notice there's no "installer" in the list of features. That's because Clojure is just another <em>dependency</em> of "our project".</p>
</blockquote>

<p>For your convenience, here's a dead simple, step-by-step environment setup for Ubuntu (<a href="http://leiningen.org/#install">other OS, sir?</a>):
<br>
<br>
<br></p>

<div class="highlight highlight-sh"><pre><span class="pl-c1">cd</span> /usr/bin
sudo curl -O https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein
sudo chmod a+x lein</pre></div>

<p>Let me explain what we just did. 
First we fetched <code>lein</code> script with <code>curl</code>° into <code>/usr/bin</code>°°.
We made sure it's executable with <code>chmod</code>.</p>

<p>°  Use <code>sudo apt-get install curl</code>, if you haven't installed it yet (doesn't come OOTB with Ubuntu).<br>
°° You can use any other dir, as long as you make sure it's in your PATH (check with <code>echo $PATH</code>), which makes possible to run it from anywhere.</p>

<p>Let's kick things off:</p>

<div class="highlight highlight-sh"><pre><span class="pl-c1">cd</span>
lein new scratch</pre></div>

<p>Here we used <code>lein new</code> to create a fresh Clojure project, based on the <code>scratch</code> template (<em>scratch</em> - as in <em>scratch the surface</em>, I guess).
Lein, in turn, installed <em>rest of itself</em> into <code>~/.lein/self-installs</code>.</p>

<p>In case you get stuck, visit <a href="http://leiningen.org/#install">lein install instructions</a>.<br>
If you want to know more, the official Leiningen tutorial can be found <a href="https://github.com/technomancy/leiningen/blob/master/doc/TUTORIAL.md">right here</a>.</p>

<p>Lovely! Now fire along:</p>

<div class="highlight highlight-sh"><pre><span class="pl-c1">cd</span> scratch
lein repl</pre></div>

<p>Boom! We have our own working Clojure environment.</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/repl.png" alt="repl"></p>

<p>REPL is short for <em>Read Eval Print Loop</em>, which is like an interactive window into a Clojure program (similar to a JavaScript console in the browser or REPL in Node).</p>

<p>Now when that's all sorted and you're eager to learn, let's see how Clojure code looks like...</p>

<h1>
<a id="basics" class="anchor" href="#basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basics</h1>

<p>A valid Clojure expression consists of <em>numbers</em>, <em>symbols</em>, <em>lists</em>, <em>keywords</em>, <em>booleans</em>, <em>characters</em>, <em>functions</em>, <em>function calls</em>, <em>macros</em> (wtf?), <em>strings</em>, <em>literal maps</em>, <em>vectors</em>, and <em>sets</em>. </p>

<p>All of those, except <em>symbols</em> and <em>lists</em>, evaluate to themselves.  </p>

<p>Symbols are similar to variables in other languages, which basically means that, when a symbol is encountered, compiler tries to find the value that the symbol was previously (hopefully) bound to, which is then used in place of the symbol.  </p>

<p>Lists take a special place in Clojure (after all, Lisp means <strong>LIS</strong>t <strong>P</strong>rocessing). They are the main building block of the language.
Lists start with a so called <em>operation form</em>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">op</span> ...)</pre></div>

<p><code>op</code> can be either:</p>

<ul>
<li>one of very few <em>special operations</em> (listed bellow)</li>
<li>a <em>macro</em>
</li>
<li>an expression that yields a <em>function</em>
</li>
</ul>

<p>For instance, if the Clojure compiler encounters:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">my-fun</span> some-expr)</pre></div>

<p>it'll first try to resolve <code>my-fun</code>, which in our case, is a previously defined function that conceptually looks like this:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">my-fun</span> <span class="pl-e">value-expr</span>)</pre></div>

<p>Then, it'll evaluate <code>some-expr</code> and invoke the <code>my-fun</code> function, passing in the result.</p>

<blockquote>
<p>so <code>my-fun</code> is a <em>symbol</em> that is bound to a function definition</p>
</blockquote>

<p>Full list of <strong>special operations</strong>:</p>

<div class="highlight highlight-clojure"><pre>def     <span class="pl-c">;evaluates an expression and binds the result to a symbol</span>
if      <span class="pl-c">;conditional evaluation</span>
fn      <span class="pl-c">;defines a function</span>
let     <span class="pl-c">;establishes a name in a local lexical scope</span>
loop    <span class="pl-c">;used for functional looping</span>
recur   <span class="pl-c">;used to support recursion in functional looping</span>
do      <span class="pl-c">;defines a block of statements</span>
new     <span class="pl-c">;allocates a new java object</span>
.       <span class="pl-c">;used to access a java method</span>
throw   <span class="pl-c">;same as in java</span>
try     <span class="pl-c">;same as in java</span>
set!    <span class="pl-c">;re-binds a symbol</span>
quote   <span class="pl-c">;supresses evaluation of an expression (same as single quote, ')</span>
var     <span class="pl-c">;provides a mechanism to refer to a mutable storage location inside a thread (?)</span></pre></div>

<p>The list above may contain some descriptions that may not be clear to you, but soon, if you stuck with it, it'll all get cleared. And that's a promise.</p>

<p>Here's how a function invocation looks like:</p>

<div class="highlight highlight-clj"><pre>user=&gt; (<span class="pl-en">inc</span> <span class="pl-c1">2</span>)      <span class="pl-c">;"increment 2"</span>
<span class="pl-c1">3</span>                   <span class="pl-c">;this is REPL output</span>
<span class="pl-c">;=&gt; 3               ;which I'll write like this from now on</span>

<span class="pl-c">; those three that begin with a semicolon are comments</span>
<span class="pl-c">;;this one also, from that first semicolon to the end of the line. All the way here -&gt;</span></pre></div>

<h2>
<a id="syntax" class="anchor" href="#syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Syntax</h2>

<h3>
<a id="prefixpolish-notation" class="anchor" href="#prefixpolish-notation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Prefix/Polish notation</h3>

<div class="highlight highlight-clj"><pre><span class="pl-c">;; intentionally skipping java semicolons</span>

<span class="pl-c">;;------------------------------------</span>
<span class="pl-c">;;     Java             Clojure</span>
<span class="pl-c">;;------------------------------------</span>
int i = <span class="pl-c1">5</span>              (<span class="pl-k">def</span> i <span class="pl-c1">5</span>)
<span class="pl-c">;;------------------------------------</span>
if(<span class="pl-en">x</span> == <span class="pl-c1">0</span>)             (<span class="pl-k">if</span> (<span class="pl-en">zero?</span> x)
  return y               y
else                     z)
  return z 
<span class="pl-c">;;------------------------------------</span>
x * y * z              (<span class="pl-en">*</span> x y z)
<span class="pl-c">;;------------------------------------</span>
foo(<span class="pl-en">x,</span> y, z)           (<span class="pl-en">foo</span> x y z)
<span class="pl-c">;;------------------------------------</span></pre></div>

<p>You can try the following example in your REPL:</p>

<div class="highlight highlight-clj"><pre><span class="pl-c">;skipping the 'user=&gt;' prompt from now on</span>
(<span class="pl-en">+</span> <span class="pl-c1">1</span> (<span class="pl-en">-</span> <span class="pl-c1">5</span> <span class="pl-c1">2</span>) (<span class="pl-en">+</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>))
<span class="pl-c">;=&gt; 11</span></pre></div>

<blockquote>
<p>Uh, that looks somewhat weird, right?</p>
</blockquote>

<p>This type of notation, inherited from Lisp, called a <em>prefix notation</em> or <em>Polish notation</em>, may look weird at the first glance.  </p>

<p>Let's back up a bit.<br>
All programming languages, in order to execute the source code, need to parse it first. 
In most languages, the product of this code parsing is a so called <em>abstract syntax tree</em> (<em>AST</em>), which is then fed into the compiler.  </p>

<p>Let's see how that tree looks for the example at hand.<br>
In Java, the expression above would be written like this:</p>

<div class="highlight highlight-java"><pre><span class="pl-c1">1</span> <span class="pl-k">+</span> (<span class="pl-c1">5</span> <span class="pl-k">-</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> (<span class="pl-c1">3</span> <span class="pl-k">+</span> <span class="pl-c1">4</span>);   <span class="pl-c">// parentheses left for clarity</span>
<span class="pl-c">// 1 + 3 + 7</span>
<span class="pl-c">// 11</span></pre></div>

<p>... and the <em>AST</em> would look like this:</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/ast.png" alt="ast"></p>

<p>After seeing what <em>AST</em> (as the ideal structure for representing code) looks like, I argue that <em>prefix</em> is the natural way of representing expressions.  </p>

<p>When you think of it (really hard), as early as first grade maths, the only option we ever see is <em>infix</em> notation, so that's what gets hardwired inside our brains.</p>

<p>That is why, IMO, the <em>Polish notation</em> looks weird to us.</p>

<blockquote>
<p>prefix notation allows any number of arguments in an operation (infix only two). Moreover, it completely eliminates the problem of operator precedence  </p>

<p>at this point I have to stress that this is my opinion after only a couple of weeks learning Clojure. I'm slightly affraid of what would happen to me after I explore all corners of the language :)</p>
</blockquote>

<h3>
<a id="clojure-is-different" class="anchor" href="#clojure-is-different" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clojure is different</h3>

<p>This is how a program is executed in a traditional, java-style <em>edit-compile-run</em> way:</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/TraditionalEvaluation.png" alt="ast"></p>

<p>In Java (and it's similar in other traditional languages), the source code gets handed to the compiler, which compiles it to bytecode. The bytecode is then run on the JVM. If you need to change something in your code, e.g. fix a bug, you need to do the whole process all over again. Open up the source file, make some changes, compile the source code, then stop the whole program and finally send the new version of bytecode to the JVM to be executed.</p>

<p>Uh, we got over that hurdle. Now we confidently start our program but we soon notice that it's still not right. OK, we stop the whole program once more and then start it in a debug mode, carefully setting breakpoints along the way. But sometimes it's not that easy, or even possible to replicate the exact context where our bug has previously occurred.</p>

<blockquote>
<p>at work, we often used to spend a better half of our day in this iterative process, doing nothing. When you combine that with IBM's tooling, that becomes a nightmare. E.g. Rational IDE weighs more than a GB. Websphere application server takes ages to start. When a new developer needs to set up his environment, it has known to take a couple of days to wire all the stuff together. We are crazy! How on earth we got eased into this unproductive way of working.</p>
</blockquote>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/ClojureEvaluation.png" alt="ast"></p>

<p>Clojure's evaluation is much more dynamic, the code first goes to <strong>Reader</strong>, which takes the characters and turns them into Clojure data structures.
The Compiler never sees the source code, it compiles the data structures produced by the Reader to bytecode, which is then run on the JVM.</p>

<p>So what does this mean? Can such a seemingly subtle difference have a noticeable impact on our development process?  </p>

<p>The point is that, this way, we can hot-swap a part of the running code without stopping the program. 
The source code doesn't have to come from a file. We can use REPL to connect to a running program and evaluate expressions on the fly.</p>

<p>The other benefit is that other programs can easily produce data structures, thus avoiding source code and Reader all together. That's the Clojure's secret sauce. It's what makes <strong>macros</strong> possible.<br>
When <em>Evaluator</em>, while processing source code, encounters a <em>macro</em> (i.e. a symbol that is bound to a <em>macro</em>), it stops executing that part of the program and sends it to that <em>macro</em>, a <em>little side-program</em> that manipulates data structures, transforming them in some useful way and then returning that, extended data structures back to the Evaluator.</p>

<p>This is extremely powerful concept, which allows us to extend the language without waiting for Rich Hickey to do so. Overwhelming amount of things, that are built-into other languages, are just macros in Clojure. For instance:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">or</span> x y)        <span class="pl-c">;'or' is a macro in Clojure </span>

<span class="pl-c">;;after being extended by or macro, becomes:</span>

(<span class="pl-k">let</span> [or__158 x]
  (<span class="pl-k">if</span> or__158 or__158 y))</pre></div>

<p>Don't worry if <em>macros</em> are not clear yet (I explained them rather poorly, I know), we'll dedicate the whole chapter to that powerful construct.</p>

<h1>
<a id="basics-this-time-for-real" class="anchor" href="#basics-this-time-for-real" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basics (this time for real)</h1>

<h2>
<a id="scalar-data-types" class="anchor" href="#scalar-data-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scalar data types</h2>

<p>A scalar data type is the one that can only hold one value at a time (value of a number, symbol, keyword, string or a character).</p>

<h3>
<a id="numeric-types" class="anchor" href="#numeric-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Numeric types</h3>

<p>The following examples of numeric expressions are trivial, so I suggest you try them out, in your REPL.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">type</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; java.lang.Long</span>

Long/MAX_VALUE
<span class="pl-c">;=&gt; 9223372036854775807</span>

(<span class="pl-en">inc</span> (<span class="pl-en">bigint</span> Long/MAX_VALUE))
<span class="pl-c">;=&gt; 9223372036854775808N</span>

(<span class="pl-en">type</span> <span class="pl-c1">5N</span>)
<span class="pl-c">;=&gt; clojure.lang.BigInt</span>

(<span class="pl-en">type</span> (<span class="pl-en">int</span> <span class="pl-c1">0</span>))
<span class="pl-c">;=&gt; java.lang.Integer</span>

(<span class="pl-en">type</span> (<span class="pl-en">short</span> <span class="pl-c1">0</span>))
<span class="pl-c">;=&gt; java.lang.Short</span>

(<span class="pl-en">type</span> (<span class="pl-en">byte</span> <span class="pl-c1">0</span>))
<span class="pl-c">;=&gt; java.lang.Byte</span>

<span class="pl-c">;; decimal, hexadecimal, octal, radix-32, and binary literals:</span>
[<span class="pl-c1">127</span> <span class="pl-c1">0x7F</span> <span class="pl-c1">0177</span> <span class="pl-c1">32r3V</span> <span class="pl-c1">2r01111111</span>]
<span class="pl-c">;=&gt; [127 127 127 127 127]</span>
<span class="pl-c">;; radix supports up to base 36</span>

(<span class="pl-en">Short/MAX_VALUE</span>)
<span class="pl-c">;=&gt; 32767</span>

(<span class="pl-en">Integer/MAX_VALUE</span>)
<span class="pl-c">;=&gt; 2147483647</span>

Byte/MAX_VALUE
<span class="pl-c">;=&gt; 127</span>

(<span class="pl-en">type</span> <span class="pl-c1">1.23</span>)
<span class="pl-c">;=&gt; java.lang.Double</span>

(<span class="pl-en">type</span> (<span class="pl-en">float</span> <span class="pl-c1">1.23</span>))
<span class="pl-c">;=&gt; java.lang.Float</span>

<span class="pl-c1">366</span>e3
<span class="pl-c">;=&gt; 366000.0</span></pre></div>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">+</span> <span class="pl-c1">1</span> <span class="pl-c1">2.0</span>)
<span class="pl-c">;=&gt; 3.0</span>

(<span class="pl-en">class</span> (<span class="pl-en">+</span> <span class="pl-c1">1</span> <span class="pl-c1">2.0</span>))
<span class="pl-c">;=&gt; java.lang.Double</span>

(<span class="pl-en">=</span> <span class="pl-c1">3</span> <span class="pl-c1">3.0</span>)
<span class="pl-c">;=&gt; false</span>

(<span class="pl-en">==</span> <span class="pl-c1">3</span> <span class="pl-c1">3.0</span>)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">*</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">1/5</span>)
<span class="pl-c">;=&gt; 6/5</span>

(<span class="pl-en">-</span> <span class="pl-c1">5</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span> <span class="pl-c1">1</span>)
<span class="pl-c">;=&gt; 2</span>

(<span class="pl-en">-</span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; -2</span>

(<span class="pl-en">*</span> <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; 4</span>

(<span class="pl-en">/</span> <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; 1/4</span>

(<span class="pl-en">+</span>)
<span class="pl-c">;=&gt; 0     ;neutral for addition</span>

(<span class="pl-en">*</span>)
<span class="pl-c">;=&gt; 1     ;neutral for multiplication</span>

(<span class="pl-en">&lt;=</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">&lt;=</span> <span class="pl-c1">1</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; false</span>

(<span class="pl-en">=</span> <span class="pl-c1">2</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; false</span>

(<span class="pl-en">=</span> <span class="pl-c1">2</span> <span class="pl-c1">2</span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; true</span></pre></div>

<p>To avoid having to round floating-point numbers (e.g. result of <code>2 / 3</code>), Clojure provides a <strong>rational</strong> number type <code>clojure.lang.Ratio</code>, thus maintaining absolute precision when dealing with floating point arithmetic:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">type</span> <span class="pl-c1">1/3</span>)
<span class="pl-c">;=&gt; clojure.lang.Ratio</span>

<span class="pl-c">;; rational numbers are automatically simplified, if possible:</span>
<span class="pl-c1">100/25</span>
<span class="pl-c">;=&gt; 4</span>

(<span class="pl-en">rational?</span> <span class="pl-c1">2</span>)   <span class="pl-c">;is rational or may be rational</span>
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">rational?</span> <span class="pl-c1">2.1</span>)
<span class="pl-c">;=&gt; false</span>

(<span class="pl-en">rationalize</span> <span class="pl-c1">2.1</span>)
<span class="pl-c">;=&gt; 21/10</span>

(<span class="pl-en">numerator</span> (<span class="pl-en">/</span> <span class="pl-c1">21</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; 21</span>

(<span class="pl-en">denominator</span> (<span class="pl-en">/</span> <span class="pl-c1">21</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; 10</span></pre></div>

<blockquote>
<p>The calculation of rational math, though accurate, isn’t nearly as fast as with floats or doubles (due to overhead cost of e.g. finding the least common denominator).</p>
</blockquote>

<p><strong>Truncation</strong></p>

<p>Truncation is a process of limiting the accuracy of floating-point numbers, due to deficiencies in its representation. When a number is truncated, its precision is limited such that the maximum number of digits of accuracy is bound by the number of bits that can fit into the storage space allowed by its representation.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [pi-constant <span class="pl-c1">3.14159265358979323846264338327950288419716939937M</span>] <span class="pl-c">;notice the M</span>
  (<span class="pl-en">println</span> (<span class="pl-en">class</span> pi-constant))
  pi-constant)
<span class="pl-c">;=&gt; java.math.BigDecimal</span>
<span class="pl-c">;=&gt; 3.14159265358979323846264338327950288419716939937M</span>

(<span class="pl-k">let</span> [pi-trunc <span class="pl-c1">3.14159265358979323846264338327950288419716939937</span>]
  (<span class="pl-en">println</span> (<span class="pl-en">class</span> pi-trunc))
  pi-trunc)
<span class="pl-c">;=&gt; java.lang.Double</span>
<span class="pl-c">;=&gt; 3.141592653589793</span></pre></div>

<p><code>M</code>, at the end of a floating-point number literal is used to tell Clojure to keep the number in its full precision.<br>
<code>N</code> is used for the same thing when dealing with longs.</p>

<blockquote>
<p>Clojure truncates floating point numbers by default</p>
</blockquote>

<p><strong>Promotion</strong></p>

<p>Clojure is able to detect when overflow occurs. Then, it automatically promotes the value to a numerical representation that can accommodate larger values</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">small</span> <span class="pl-c1">9</span>)
(<span class="pl-en">class</span> small)
<span class="pl-c">;=&gt; java.lang.Long</span>

(<span class="pl-en">class</span> (<span class="pl-en">+</span> small <span class="pl-c1">90000000000000000000</span>))
<span class="pl-c">;=&gt; clojure.lang.BigInt</span>

(<span class="pl-en">class</span> (<span class="pl-en">+</span> small <span class="pl-c1">9.0</span>))
<span class="pl-c">;=&gt; java.lang.Double</span>

(<span class="pl-en">+</span> Integer/MAX_VALUE Integer/MAX_VALUE)
<span class="pl-c">;=&gt; 4294967294</span>

(<span class="pl-en">class</span> (<span class="pl-en">+</span> Integer/MAX_VALUE Integer/MAX_VALUE))
<span class="pl-c">;=&gt; java.lang.Long</span></pre></div>

<blockquote>
<p>There's no limit to integer size in Clojure, besides RAM size</p>
</blockquote>

<h3>
<a id="strings-and-characters" class="anchor" href="#strings-and-characters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strings and Characters</h3>

<p>String is any sequence of characters enclosed in double quotes, including newlines:</p>

<div class="highlight highlight-clj"><pre><span class="pl-s"><span class="pl-pds">"</span>this is a string</span>
<span class="pl-s">on two lines<span class="pl-pds">"</span></span>
<span class="pl-c">;=&gt; "this is a string\non two lines"  ;REPL output includes newline escape</span>

(<span class="pl-en">type</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; java.lang.String</span>

(<span class="pl-en">str</span> <span class="pl-c1">nil</span>)    <span class="pl-c">;'nil' is Clojure's 'null'</span>
<span class="pl-c">;=&gt; ""</span></pre></div>

<blockquote>
<p>single quote, backtick and <code>quote</code> (though with slightly different properties) are used to include literals in a program without evaluating them</p>
</blockquote>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">str</span> 'cat)
<span class="pl-c">;=&gt; "cat"</span>

(<span class="pl-en">str</span> 'a')
<span class="pl-c">;=&gt; "a'"</span>

(<span class="pl-en">str</span> <span class="pl-c1">1</span>)
<span class="pl-c">;=&gt; "1"</span>

(<span class="pl-en">str</span> '<span class="pl-c1">1</span>)
<span class="pl-c">;=&gt; "1"</span>

(<span class="pl-en">str</span> <span class="pl-c1">true</span>)
<span class="pl-c">;=&gt; "true"</span>

(<span class="pl-en">str</span> '(<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; "(1 2 3)"</span>

(<span class="pl-en">str</span> <span class="pl-s"><span class="pl-pds">"</span>meow <span class="pl-pds">"</span></span> <span class="pl-c1">3</span> <span class="pl-s"><span class="pl-pds">"</span> times<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; "meow 3 times"</span>

<span class="pl-c">;characters are denoted by backslash</span>
\a
<span class="pl-c">;=&gt; \a</span>

\u0042
<span class="pl-c">;=&gt; \B</span>

\\
<span class="pl-c">;=&gt; \\</span></pre></div>

<h2>
<a id="symbols" class="anchor" href="#symbols" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols</h2>

<p>Symbols can have either short or full names. The short name is used to refer to things locally, and the <em>fully qualified name</em> is used to refer unambiguously to a symbol (from anywhere).
Symbol names are separated with a <code>/</code>. For instance, the symbol <code>str</code> is also present in a namespace called <code>clojure.core</code> and the corresponding full name is <code>clojure.core/str</code>
The main purpose of symbols is to refer to <em>things</em>, i.e. to point to other values. When evaluating a program, symbols are looked up and replaced by their corresponding values. </p>

<blockquote>
<p><a href="#symbols">more about symbols</a></p>
</blockquote>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">=</span> str clojure.core/str)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">name</span> 'clojure.core/str)
<span class="pl-c">;=&gt; "str"</span></pre></div>

<h2>
<a id="keywords" class="anchor" href="#keywords" aria-hidden="true"><span class="octicon octicon-link"></span></a>Keywords</h2>

<p>Closely related to symbols and strings are keywords, which begin with a <code>:</code>.<br>
Keywords are like strings in that they are made up of text, but are specifically intended for use as labels or identifiers. These are not labels in the sense of symbols, keywords are not replaced by any other value, they are just names, by themselves:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">type</span> <span class="pl-c1">:cat</span>)
<span class="pl-c">;=&gt; clojure.lang.Keyword</span>

(<span class="pl-en">str</span> <span class="pl-c1">:cat</span>)
<span class="pl-c">;=&gt; ":cat"</span>

(<span class="pl-en">name</span> <span class="pl-c1">:cat</span>)
<span class="pl-c">;=&gt; "cat"</span></pre></div>

<p><strong>Using keywords as map keys</strong></p>

<blockquote>
<p>since keywords are self-evaluating and provide fast equality checks, they are almost always used as map keys</p>
</blockquote>

<p>Another important property of keywords, when used as map keys, is that they can be used as functions, taking a map as an argument to perform value lookups:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">mouse-planet</span> {<span class="pl-c1">:cats</span> <span class="pl-c1">180</span>, <span class="pl-c1">:mice</span> <span class="pl-c1">9</span>})   <span class="pl-c">;define a map</span>
<span class="pl-c">;=&gt; #'user/mouse-planet</span>

(<span class="pl-c1">:cats</span> mouse-planet)                      <span class="pl-c">;lookup by keyword</span>
<span class="pl-c">;=&gt; 180</span>

(<span class="pl-en">println</span> (<span class="pl-en">/</span> (<span class="pl-c1">:cats</span> mouse-planet)          <span class="pl-c">;much more useful example</span>
            (<span class="pl-c1">:mice</span> mouse-planet))
         <span class="pl-s"><span class="pl-pds">"</span>cats per capita<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; 20 cats per capita</span></pre></div>

<p><strong>As enumerations</strong></p>

<p>Since their value doesn't change, convenient keyword use case is enumeration. E.g. <code>:mouse</code>, <code>:rat</code> and <code>:x-rat</code> provide a nice visual delineation (for mouse types) within a source code.</p>

<blockquote>
<p>there are other useful things we can do with keywords. We can use them <strong>As multimethod dispatch values</strong> and <strong>As directives</strong>, but we'll deal with that later</p>
</blockquote>

<p><strong>Qualifying your keywords</strong></p>

<p>Keywords don't belong to any specific namespace, although it's a good practice to define them as if they do, because that way you provide a context:</p>

<div class="highlight highlight-clj"><pre>user=&gt; <span class="pl-c1">:not-in-ns</span>
<span class="pl-c">;=&gt; :not-in-ns</span>

user=&gt; <span class="pl-c1">::not-in-ns</span>          <span class="pl-c">;fully qualified keyword</span>
<span class="pl-c">;=&gt; :user/not-in-ns</span>

user=&gt; (<span class="pl-k">ns</span> <span class="pl-e">another</span>)
<span class="pl-c">;=&gt; nil</span>

another=&gt; <span class="pl-c1">:user/in-another</span>  <span class="pl-c">;"fully qualified" keyword</span>
<span class="pl-c">;=&gt; :user/in-another</span>

another=&gt; <span class="pl-c1">:haunted/name</span>     <span class="pl-c">;namespace doesn't have to exist</span>
<span class="pl-c">;=&gt; :haunted/name</span></pre></div>

<blockquote>
<p>double colon is used to fully qualify a keyword by prepending the current namespace name to the keyword name</p>

<p>equally named keywords are the same object in memory</p>
</blockquote>

<h2>
<a id="booleans" class="anchor" href="#booleans" aria-hidden="true"><span class="octicon octicon-link"></span></a>Booleans</h2>

<p>Only <code>false</code> and <code>nil</code> are logical <code>false</code>, all others values are <code>true</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">boolean</span> <span class="pl-c1">nil</span>)
<span class="pl-c">;=&gt; false</span>

(<span class="pl-en">boolean</span> <span class="pl-c1">0</span>)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">boolean</span> <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">boolean</span> str)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">and</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">true</span>)
<span class="pl-c">;=&gt; false</span>

(<span class="pl-en">and</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span>)
<span class="pl-c">;=&gt; true</span></pre></div>

<p>... and returns the first <em>falsy</em> value, or the last value if all are <em>truthy</em>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">and</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; 3</span>

(<span class="pl-en">and</span> <span class="pl-c1">-1</span> <span class="pl-c1">nil</span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; nil</span></pre></div>

<p>or returns the first <em>truthy</em> value, or the last value if all are <em>falsy</em>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">or</span> <span class="pl-c1">false</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; 2</span>

(<span class="pl-en">or</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">nil</span>)
<span class="pl-c">;=&gt; nil</span></pre></div>

<p><code>not</code> inverses the <em>truthiness</em> of the expression:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">not</span> <span class="pl-c1">nil</span>)
<span class="pl-c">;=&gt; true</span></pre></div>

<h2>
<a id="regular-expressions" class="anchor" href="#regular-expressions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Regular expressions</h2>

<p><code>#"..."</code> is Clojure’s way of writing a regular expression.<br>
Clojure and Java have very similar Regex syntax.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">re-find</span> <span class="pl-sr">#"cat"</span> <span class="pl-s"><span class="pl-pds">"</span>mystic cat mouse<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; "cat"</span>

(<span class="pl-en">re-find</span> <span class="pl-sr">#"cat"</span> <span class="pl-s"><span class="pl-pds">"</span>only dogs here<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; nil</span></pre></div>

<p>The parentheses, i.e. <em>capturing group</em> means that the regular expression should capture that part of the match. We get back a <em>list</em> containing the part of the string that matched the first parentheses, followed by the part that matched the second parentheses, etc:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">re-matches</span> <span class="pl-sr">#"(.+):(.+)"</span> <span class="pl-s"><span class="pl-pds">"</span>mouse:treat<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; ["mouse:treat" "mouse" "treat"]</span>

<span class="pl-c">;; capturing group in the regex causes each returned item to be a vector:</span>
(<span class="pl-en">re-seq</span> <span class="pl-sr">#"\w*(\w)"</span> <span class="pl-s"><span class="pl-pds">"</span>one-two/three<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; (["one" "e"] ["two" "o"] ["three" "e"])</span></pre></div>

<p>Java's regex <code>Pattern</code> class has several methods that can be used directly, but only <code>split</code> is used regularly to split a string into an array of Strings:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">seq</span> (<span class="pl-en">.split</span> <span class="pl-sr">#","</span> <span class="pl-s"><span class="pl-pds">"</span>1,2,3,4<span class="pl-pds">"</span></span>))  <span class="pl-c">;this is how you call Java methods</span>
<span class="pl-c">;=&gt; ("1" "2" "3" "4")</span></pre></div>

<p><a href="#java-interop">Java interoperability section.</a>  </p>

<p>The <code>re-seq</code> function returns a lazy sequence of all matches in a string:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">re-seq</span> <span class="pl-sr">#"\w+"</span> <span class="pl-s"><span class="pl-pds">"</span>one-two/three<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; ("one" "two" "three")</span></pre></div>

<blockquote>
<p>Java's regex engine includes a <code>Matcher</code> object which mutates in a non-thread-safe way as it walks through a string finding matches. This object is exposed in Clojure through the <code>re-matcher</code> function and can be used in combination with <code>re-groups</code> and <code>re-find</code>.
It's recommended to avoid direct usage of all of these three functions.</p>
</blockquote>

<h1>
<a id="collections" class="anchor" href="#collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collections</h1>

<p>A collection is a group of values. It’s a container which provides some structure, some framework, for the things that it holds. We refer to collection members as elements, or items.</p>

<p>All Clojure's collections support heterogeneous values (values of arbitrary types), together, in the same collection.</p>

<blockquote>
<p>when a collection is evaluated (except lists), each of its contained items is evaluated first</p>
</blockquote>

<p>Most of functions that work on collections aren't actually written to work on concrete collection types, but rather to work on abstract data types. For instance, some of abstractions in this space are:</p>

<ul>
<li>Collection  (common to all concrete types)</li>
<li>Sequential  (ordered collections are lists and vectors)</li>
<li>Associative (maps associate keys with values, vectors associate indices with values)</li>
<li>Indexed     (vectors, for example, can be quickly indexed into)</li>
</ul>

<h2>
<a id="lists" class="anchor" href="#lists" aria-hidden="true"><span class="octicon octicon-link"></span></a>Lists</h2>

<p>A <code>PersistentList</code> is a singly linked list where each node knows its distance from the end. 
List elements can only be found by starting with the first element and walking each prior node in order. 
List elements can only be added or removed from the left end.</p>

<p>In idiomatic Clojure code, lists are used almost exclusively to represent code forms, e.g. to call functions, macros, ...
Code forms are then <code>eval</code>-ed or used as the return value for a macro.</p>

<blockquote>
<p>Lists are rarely used for anything other than to represent Clojure source code, because they rarely offer any value over vectors</p>
</blockquote>

<p>Literal lists are written with parentheses: <code>(yankee hotel foxtrot)</code>.</p>

<p>When a list is evaluated, the first item of the list, <code>yankee</code>, will be resolved to a <em>function</em>, <em>macro</em>, or <em>special form</em>. 
If <code>yankee</code> is a <em>function</em>, the remaining items in the list will be evaluated in order, and the results will be passed to <code>yankee</code> as its parameters.
If <code>yankee</code> is a <em>macro</em> or a <em>special form</em>, the remaining items in the list
aren’t necessarily evaluated, but are processed as defined by the <em>macro</em> or <em>operator</em>.</p>

<blockquote>
<p><strong>special form</strong> is a form with special syntax or special evaluation rules that are typically not implemented using the base Clojure forms. An example of a special form is
the <code>.</code> (dot) operator used for Java interoperability purposes.</p>
</blockquote>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">cons</span> <span class="pl-c1">1</span> (<span class="pl-c1">2</span> <span class="pl-c1">3</span>))

<span class="pl-c">;=&gt; ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn</span>
<span class="pl-c">;;which basically means that the number 2 cannot be used as a function</span>

(<span class="pl-en">cons</span> <span class="pl-c1">1</span> '(<span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; (1 2 3)</span></pre></div>

<p>Remember, we quote lists (any everything else needed quoting) with a <code>'</code> (or <code>quote</code>) to prevent them from being evaluated.  </p>

<div class="highlight highlight-clj"><pre>'(<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; (1 2 3)</span>

(<span class="pl-en">type</span> '(<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; clojure.lang.PersistentList</span></pre></div>

<p>There's also a <strong>syntax-quote</strong> (back-tick), which automatically qualifies all unqualified symbols in its argument:</p>

<div class="highlight highlight-clj"><pre>`map
<span class="pl-c">;=&gt; clojure.core/map</span>

`(map even? [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; (clojure.core/map clojure.core/even? [1 2 3])</span></pre></div>

<p>You can also construct a list using <code>list</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
(<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
(<span class="pl-en">=</span> (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>) (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>))
<span class="pl-c1">true</span></pre></div>

<p>You can modify a list by <em>conjoining</em> an element onto it (as always with lists, the new element goes to the beginning):</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">conj</span> (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>) <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; (4 1 2 3)</span>

(<span class="pl-en">first</span> (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; 1</span>

(<span class="pl-en">second</span> (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; 2</span>

(<span class="pl-en">nth</span> (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>) <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; 3</span></pre></div>

<p>Unlike some <em>Lisps</em>, the empty list in Clojure, <code>()</code>, isn't the same as <code>nil</code>.
Lists are well-suited for small collections, or collections which are read in linear order, but are slow when you want to get arbitrary elements from later in the list. </p>

<blockquote>
<p>Calling <code>seq</code> on a list returns the list itself, but more often, calling <code>seq</code> on a collection returns a new <code>seq</code> object for navigating that collection.</p>
</blockquote>

<h3>
<a id="what-lists-arent" class="anchor" href="#what-lists-arent" aria-hidden="true"><span class="octicon octicon-link"></span></a>What lists aren't?</h3>

<p>Probably the most common misuse of lists is to hold items that will be looked up by index. Though you can use <code>nth</code> to get the element, Clojure will have to walk the list from the beginning to find it.  </p>

<p>Lists aren't queues. You can add items to one end, but you can't remove from the other.</p>

<h3>
<a id="persistentqueue" class="anchor" href="#persistentqueue" aria-hidden="true"><span class="octicon octicon-link"></span></a>PersistentQueue</h3>

<p>Persistent immutable queue is a FIFO structure where <code>conj</code> adds to the rear, <code>pop</code> removes from the front and <code>peek</code> returns the front element without removal.</p>

<p>Clojure currently doesn't provide a core construction function for creating persistent queues, but there's a readily available empty queue instance to use, <code>clojure.lang.PersistentQueue/EMPTY</code>.</p>

<p>The printed representation for Clojure's queues isn't particularly informative, but we can change that by providing a method for them on the <code>print-method</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defmethod</span> print-method clojure.lang.PersistentQueue
  [q, w]
  (<span class="pl-en">print-method</span> '&lt;- w) (<span class="pl-en">print-method</span> (<span class="pl-en">seq</span> q) w) (<span class="pl-en">print-method</span> '-&lt; w))

clojure.lang.PersistentQueue/EMPTY
<span class="pl-c">;=&gt; &lt;-nil-&lt;</span></pre></div>

<blockquote>
<p>Popping an empty queue results in just another empty queue. Peeking an empty queue returns <code>nil</code></p>
</blockquote>

<p>The mechanism for adding an element to a queue is <code>conj</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">tasks</span>
  (<span class="pl-en">conj</span> clojure.lang.PersistentQueue/EMPTY
  <span class="pl-c1">:wake-up</span> <span class="pl-c1">:shower</span> <span class="pl-c1">:brush-teeth</span>))
<span class="pl-c">;=&gt; #'mbo/tasks</span>

tasks
<span class="pl-c">;=&gt; &lt;-(:wake-up :shower :brush-teeth)-&lt;</span></pre></div>

<blockquote>
<p>Clojure's persistent queue is implemented internally using two separate collections, the front being a seq and the rear being a vector. All insertions occur in the rear vector and all removals occur in the front seq, taking advantage of each collection's strength. When all the items from the front have been popped, the back vector is wrapped in a seq to become the new front and an empty vector is used as the new back</p>
</blockquote>

<p>To get the front element, we use <code>peek</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">peek</span> tasks)
<span class="pl-c">;=&gt; :wake-up</span></pre></div>

<p>To remove elements from the front of a queue, we use <code>pop</code> (although possible, it's non-idiomatic and suboptimal to use <code>rest</code> with queues, because it returns a seq, not a queue and <em>screws up</em> the speed guarantees):</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">pop</span> tasks)       <span class="pl-c">;; returns new list, remember?</span>
<span class="pl-c">;=&gt; &lt;-(:shower :brush-teeth)-&lt;</span>

(<span class="pl-en">rest</span> tasks)
<span class="pl-c">;=&gt; (:shower :brush-teeth)</span></pre></div>

<h2>
<a id="vectors" class="anchor" href="#vectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vectors</h2>

<p>For fast access to every element, we use a <strong>vector</strong>.
Vectors are surrounded by square brackets, just like lists are surrounded by parentheses. Because vectors aren’t evaluated like lists are, there is no need to quote the vector literal:</p>

<div class="highlight highlight-clj"><pre>[<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>]
<span class="pl-c">;=&gt; [1 2 3]</span>

(<span class="pl-en">type</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; clojure.lang.PersistentVector</span></pre></div>

<blockquote>
<p>Vectors are similar to arrays, but are immutable and persistent</p>
</blockquote>

<p>You can also create vectors with <code>vector</code>, or change other structures into vectors with <code>vec</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">vector</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; [1 2 3]</span>

(<span class="pl-en">vec</span> (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; [1 2 3]</span></pre></div>

<p><code>conj</code> on a vector adds to the end, not the start, like with lists:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">conj</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; [1 2 3 4]</span></pre></div>

<p>Our friends <code>first</code>, <code>second</code>, and <code>nth</code> work here too; but unlike lists, <code>nth</code> is fast on vectors. That’s because internally, vectors are represented as a very broad tree of elements, where each part of the tree branches into 32 smaller trees. Even very large vectors are only a few layers deep, which means getting to elements only takes a few hops, which is why retrieval operation from the interior of a vector takes essentially a constant time.</p>

<p>The important difference, when compared to lists, is that vectors evaluate each item in order. No function or macro is performed on a vector itself.</p>

<p><code>rest</code> and <code>next</code> both return <em>everything but the first element</em>. They differ only by what happens when there are no remaining elements:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">rest</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (2 3 4)</span>

(<span class="pl-en">next</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (2 3 4)</span></pre></div>

<p><code>rest</code> returns logical <code>true</code>, <code>next</code> returns logical <code>false</code>. Each has their uses, but in almost every case they’re equivalent:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">next</span> [<span class="pl-c1">1</span>])
<span class="pl-c">;=&gt; nil</span>

(<span class="pl-en">rest</span> [<span class="pl-c1">1</span>])
<span class="pl-c">;=&gt; ()</span></pre></div>

<p><code>last</code>, surprisingly, returns the last element:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">last</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; 3</span></pre></div>

<p><code>count</code>, shockingly, returns element count:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">count</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; 4</span></pre></div>

<p>You can use element's index to access it:</p>

<div class="highlight highlight-clj"><pre>([<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] <span class="pl-c1">1</span>)  <span class="pl-c">;vectors are in fact functions of their indices</span>
<span class="pl-c">;=&gt; 2</span></pre></div>

<p>Vectors and lists containing the same elements are considered equal:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span>] (<span class="pl-en">list</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>))
<span class="pl-c">;=&gt; true</span></pre></div>

<p>If you already have a vector but want to "pour" several values into it, use <code>into</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [m-vector [<span class="pl-c1">:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span>]]
  (<span class="pl-en">into</span> m-vector (<span class="pl-en">range</span> <span class="pl-c1">10</span>)))
<span class="pl-c">;=&gt; [:a :b :c 0 1 2 3 4 5 6 7 8 9]</span>

<span class="pl-c">;;if you want to return a vector the first arg to 'into' must be a vector</span>
<span class="pl-c">;;the second argument must be anything that works with 'seq' function</span></pre></div>

<h3>
<a id="primitive-vectors" class="anchor" href="#primitive-vectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primitive vectors</h3>

<p>You can store primitive types inside of vectors using the <code>vector-of</code> function, which takes any of <code>:int</code>, <code>:long</code>, <code>:float</code>, <code>:double</code>, <code>:byte</code>, <code>:short</code>, <code>:boolean</code> and <code>:char</code> and returns an empty vector. This returned vector will act just like any other vector, except that, internally, it'll store its contents as primitives.<br>
The new vector will try to coerce any additions into its internal type when they are being added:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">into</span> (<span class="pl-en">vector-of</span> <span class="pl-c1">:int</span>) [Math/PI <span class="pl-c1">2</span> <span class="pl-c1">1.3</span>])
<span class="pl-c">;=&gt; [3 2 1]</span>

(<span class="pl-en">into</span> (<span class="pl-en">vector-of</span> <span class="pl-c1">:char</span>) [<span class="pl-c1">100</span> <span class="pl-c1">101</span> <span class="pl-c1">102</span>])
<span class="pl-c">;=&gt; [\d \e \f]</span>

(<span class="pl-en">into</span> (<span class="pl-en">vector-of</span> <span class="pl-c1">:int</span>) [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">609812734019519652839108477134</span>])

<span class="pl-c">;=&gt; IllegalArgumentException Value out of range for long: 60981273401951...</span>
<span class="pl-c">;=&gt; clojure.lang.RT.longCast (RT.java:1134)</span></pre></div>

<h3>
<a id="large-vectors" class="anchor" href="#large-vectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Large vectors</h3>

<p>Vectors are particularly efficient at three things (relative to lists): </p>

<ul>
<li>adding or removing things from the right end of the collection</li>
<li>accessing or changing items in the interior of the collection by numeric index</li>
<li>walking in reverse order</li>
</ul>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">a-to-e</span> (<span class="pl-en">vec</span> (<span class="pl-en">map</span> char (<span class="pl-en">range</span> <span class="pl-c1">65</span> <span class="pl-c1">70</span>))))
<span class="pl-c">;=&gt; #'mbo/a-to-z</span>

a-to-e
<span class="pl-c">;=&gt; [\A \B \C \D \E]</span>

(<span class="pl-en">nth</span> a-to-e <span class="pl-c1">4</span>)   <span class="pl-c">;like with a map</span>
<span class="pl-c">;=&gt; \E</span>

(<span class="pl-en">get</span> a-to-e <span class="pl-c1">4</span>)   <span class="pl-c">;like with a map</span>
<span class="pl-c">;=&gt; \E</span>

(<span class="pl-en">a-to-e</span> <span class="pl-c1">4</span>)       <span class="pl-c">;invoking a vector as a function</span>
<span class="pl-c">;=&gt; \E</span></pre></div>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/vector-lookup-options.png" alt="vector-lookup-options"></p>

<p>Since vectors are indexed, they can be efficiently walked in either direction. The <code>seq</code> and <code>rseq</code> return sequences that do exactly that:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">seq</span> a-to-e)
<span class="pl-c">;=&gt; (\A \B \C \D \E)</span>

(<span class="pl-en">rseq</span> a-to-e)
<span class="pl-c">;=&gt; (\E \D \C \B \A)</span></pre></div>

<p>Any item in a vector can be "changed" using the <code>assoc</code> function (in a constant time). Clojure does this using <em>structural sharing</em> between the old and the new vectors, hence avoiding having to copy all the elements.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">assoc</span> a-to-e <span class="pl-c1">3</span> <span class="pl-s"><span class="pl-pds">"</span>former D<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; [\A \B \C "former D" \E]</span></pre></div>

<p>The <code>assoc</code> function works only on indices that either already exist or, as a special case, exactly one step past the end of a vector (returned vector becomes one item larger).</p>

<p>Function <code>replace</code> uses <code>assoc</code> internally:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">replace</span> {<span class="pl-c1">2</span> :a, <span class="pl-c1">4</span> <span class="pl-c1">:b</span>} [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; [1 :a 3 :a 3 :b]</span></pre></div>

<p>The functions <code>assoc-in</code>, <code>update-in</code> and <code>get-in</code> are used to work with nested structures of vectors and/or maps. These functions take a series of indices to pick items from each more deeply nested level:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">matrix</span>
  [[<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>]
   [<span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>]
   [<span class="pl-c1">7</span> <span class="pl-c1">8</span> <span class="pl-c1">9</span>]])
<span class="pl-c">;=&gt; #'mbo/matrix</span>

(<span class="pl-en">get-in</span> matrix [<span class="pl-c1">1</span> <span class="pl-c1">2</span>])   <span class="pl-c">;second row, third column</span>
<span class="pl-c">;=&gt; 6</span>

(<span class="pl-en">assoc-in</span> matrix [<span class="pl-c1">1</span> <span class="pl-c1">2</span>] 'x)
<span class="pl-c">;=&gt; [[1 2 3] [4 5 x] [7 8 9]]</span></pre></div>

<p><code>update-in</code> works the similar way, but instead of taking a value to "overwrite" an existing value, it takes a function to <em>apply</em> to an existing value. It'll replace the value at the given coordinates with the return value of the function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">update-in</span> matrix [<span class="pl-c1">1</span> <span class="pl-c1">2</span>] * <span class="pl-c1">100</span>)
<span class="pl-c">;=&gt; [[1 2 3] [4 5 600] [7 8 9]]</span>

<span class="pl-c">;; the coordinates refer to the value 6 and the function is * taking an argument 100</span>
<span class="pl-c">;; so the slot becomes the return value of (* 6 100)</span></pre></div>

<p>Remember? <code>matrix</code> itself never changed:</p>

<div class="highlight highlight-clj"><pre>matrix
<span class="pl-c">;=&gt; [[1 2 3] [4 5 6] [7 8 9]]</span></pre></div>

<h3>
<a id="vectors-as-stacks" class="anchor" href="#vectors-as-stacks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vectors as stacks</h3>

<p>Clojure vectors uses <code>conj</code> as <code>push</code> and <code>pop</code> as <code>pop</code> to add and remove elements from the right side. Since vectors are immutable, <code>pop</code> returns a new vector with the rightmost element dropped, which is different from many mutable stack APIs, which generally return the dropped item. Consequently, <code>peek</code> becomes more important as the primary way to get an item from the top of the stack:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">peek</span> m-stack)
<span class="pl-c">;=&gt; 3</span>

(<span class="pl-en">pop</span> m-stack)
<span class="pl-c">;=&gt; [1 2]</span>

(<span class="pl-en">conj</span> m-stack <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; [1 2 3 4]</span>

(<span class="pl-en">+</span> (<span class="pl-en">peek</span> m-stack) (<span class="pl-en">peek</span> (<span class="pl-en">pop</span> m-stack)))
<span class="pl-c">;=&gt; 5</span></pre></div>

<blockquote>
<p>If you're using a collection (any implementor of <code>clojure.lang.IPersistentStack</code>) as a stack, it's idiomatic to use <code>conj</code> instead of <code>assoc</code>, <code>peek</code> instead of <code>last</code> and <code>pop</code> instead of <code>dissoc</code>. That avoids unnecessary confusion about how the collection is being used</p>

<p>Lists also implement <code>IPersistentStack</code>, but the functions there operate on the left side, i.e. beginning of the list</p>
</blockquote>

<h3>
<a id="using-vectors-instead-of-reverse" class="anchor" href="#using-vectors-instead-of-reverse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using vectors instead of reverse</h3>

<p>When processing a list, it's pretty common to want to produce a new list in the same order. But if all you have is list, then you're left with backward list that needs to be reversed:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">m-map1</span> [f coll]
  (<span class="pl-k">loop</span> [coll coll, acc <span class="pl-c1">nil</span>]
    (<span class="pl-k">if</span> (<span class="pl-en">empty?</span> coll)
      (<span class="pl-en">reverse</span> acc)
      (<span class="pl-k">recur</span> (<span class="pl-en">next</span> coll) (<span class="pl-en">cons</span> (<span class="pl-en">f</span> (<span class="pl-en">first</span> coll)) acc)))))
<span class="pl-c">;=&gt; #'mbo/m-map1</span>

(<span class="pl-en">m-map1</span> - (<span class="pl-en">range</span> <span class="pl-c1">5</span>))
<span class="pl-c">;=&gt; (0 -1 -2 -3 -4)</span></pre></div>

<p>After the entire list has been walked once to produce the desired values, <code>reverse</code> walks it again to get them in the right order, which is inefficient and non-idiomatic.
One way to avoid <code>reverse</code> is to use a vector as the accumulator, instead of a list:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">m-map2</span> [f coll]
  (<span class="pl-k">loop</span> [coll coll, acc []]
    (<span class="pl-k">if</span> (<span class="pl-en">empty?</span> coll)
      acc
      (<span class="pl-k">recur</span> (<span class="pl-en">next</span> coll) (<span class="pl-en">conj</span> acc (<span class="pl-en">f</span> (<span class="pl-en">first</span> coll)))))))
<span class="pl-c">;=&gt; #'mbo/m-map2</span>

(<span class="pl-en">m-map2</span> - (<span class="pl-en">range</span> <span class="pl-c1">5</span>))
<span class="pl-c">;=&gt; [0 -1 -2 -3 -4]</span></pre></div>

<h3>
<a id="subvectors" class="anchor" href="#subvectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subvectors</h3>

<p>Provide a fast way to take a slice of an existing vector based on start and end indices.
To produce a subvector we use the <code>subvec</code> function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">subvec</span> a-to-e <span class="pl-c1">2</span> <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; [\C \D]</span>

<span class="pl-c">;;first index is inclusive, but the second is exclusive</span></pre></div>

<blockquote>
<p>There's a special logic for taking a <code>subvec</code> of a <code>subvec</code>, in which case the newest subvector keeps a reference to the original vector, not the intermediate subvector, which keeps both the creation and use of sub-subvectors fast and efficient.</p>
</blockquote>

<h3>
<a id="vectors-as-mapentries" class="anchor" href="#vectors-as-mapentries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vectors as MapEntries</h3>

<p>Clojure's hash map, just like hash tables and dictionaries in many other languages, has a mechanism to iterate through the entire collection. Clojure's solution for this iterator is, you guessed it - <code>seq</code>.<br>
Each item in this seq needs to include both the key and the value, hence they are wrapped in a <code>MapEntry</code>. When printed, each entry looks like a vector:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">first</span> {<span class="pl-c1">:width</span> <span class="pl-c1">10</span> <span class="pl-c1">:height</span> <span class="pl-c1">20</span> <span class="pl-c1">:depth</span> <span class="pl-c1">15</span>})
<span class="pl-c">;=&gt; [:depth 15]</span>

<span class="pl-c">;;not only does it look like a vector, it really is one:</span>
(<span class="pl-en">vector?</span> (<span class="pl-en">first</span> {<span class="pl-c1">:width</span> <span class="pl-c1">10</span> <span class="pl-c1">:height</span> <span class="pl-c1">20</span> <span class="pl-c1">:depth</span> <span class="pl-c1">15</span>}))
<span class="pl-c">;=&gt; true</span>

<span class="pl-c">;;which means you can use all the regular vector functions on it</span>
<span class="pl-c">;;it even supports destructuring*</span></pre></div>

<p><a href="#destructuring">destructuring?</a></p>

<div class="highlight highlight-clj"><pre><span class="pl-c">;;e.g. the following locals, 'dimension' and 'amount', will take on the value of each</span>
<span class="pl-c">;;key/value pair in turn:</span>
(<span class="pl-en">doseq</span> [[dimension amount] {<span class="pl-c1">:width</span> <span class="pl-c1">10</span>, <span class="pl-c1">:height</span> <span class="pl-c1">20</span>, <span class="pl-c1">:depth</span> <span class="pl-c1">15</span>}]
  (<span class="pl-en">println</span> (<span class="pl-en">str</span> (<span class="pl-en">name</span> dimension) <span class="pl-s"><span class="pl-pds">"</span>:<span class="pl-pds">"</span></span>) amount <span class="pl-s"><span class="pl-pds">"</span> inches<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; depth: 15  inches</span>
<span class="pl-c">;=&gt; width: 10  inches</span>
<span class="pl-c">;=&gt; height: 20  inches</span>
<span class="pl-c">;=&gt; nil</span>

(<span class="pl-en">doc</span> doseq)
<span class="pl-c">;=&gt; -------------------------</span>
<span class="pl-c">;=&gt; clojure.core/doseq</span>
<span class="pl-c">;=&gt; ([seq-exprs &amp; body])</span>
<span class="pl-c">;=&gt; Macro</span>
<span class="pl-c">;=&gt;   Repeatedly executes body (presumably for side-effects) with</span>
<span class="pl-c">;=&gt;   bindings and filtering as provided by "for".  Does not retain</span>
<span class="pl-c">;=&gt;   the head of the sequence. Returns nil.</span></pre></div>

<p>A <code>MapEntry</code> is its own type and has two functions for retrieving its contents, <code>key</code> and <code>val</code>, which do exactly the same thing as <code>(nth m-map 0)</code> and <code>(nth m-map 1)</code>.</p>

<h3>
<a id="what-vectors-arent" class="anchor" href="#what-vectors-arent" aria-hidden="true"><span class="octicon octicon-link"></span></a>What vectors aren't?</h3>

<p>Vectors are versatile, but there are some useful patterns where they might seem like a good fit, but in fact the aren't.</p>

<p><strong>Vectors aren't sparse</strong></p>

<p>If you have a vector of length <em>n</em>, the only position where you can insert a value is at index <em>n</em>, appending to the far right end. You can't skip some indices and insert at a higher index number (use hash map or sorted map).<br>
Although you can replace values within a vector, you can't insert or delete items such that indices are adjusted (use finger trees for that).</p>

<p><strong>Vectors aren't queues</strong></p>

<p>Use a <a href="#persistentqueue">PersistentQueue</a> for that.</p>

<p><strong>Vectors aren't sets</strong></p>

<p>If you want to find out whether a vector contains a particular value, you might be tempted to use the <code>contains?</code> function, but that function checks whether a specific <em>key</em>, not <em>value</em> is in a collection, which is really not useful for a vector.</p>

<blockquote>
<p>Vectors are probably the most frequently used collection type in Clojure. They are used as literals for argument lists and <code>let</code> bindings, for holding large amounts of application data and as stacks and map entries</p>

<p>In almost all contexts, you can consider vectors, lists, and other sequences as interchangeable. They only differ in their performance characteristics, and in a few data-structure-specific operations.</p>
</blockquote>

<h2>
<a id="sets" class="anchor" href="#sets" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sets</h2>

<p>Set is a collection of unordered, unique elements.</p>

<p>Sets are surrounded by <code>#{...}</code>:</p>

<div class="highlight highlight-clj"><pre>#{<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>}
<span class="pl-c">;=&gt; #{1 2 3}</span>

(<span class="pl-en">#{:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span> <span class="pl-c1">:d</span>} <span class="pl-c1">:c</span>)
<span class="pl-c">;=&gt; :c</span>

(<span class="pl-en">#{:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span> <span class="pl-c1">:d</span>} <span class="pl-c1">:e</span>)
<span class="pl-c">;=&gt; nil</span></pre></div>

<p>If you look at the previous two expressions, you'll see that the sets are in fact functions of their elements that return the matched element or <code>nil</code> if the element is not present (take a pause and read that a couple more times, examining the examples).</p>

<p>Elements can be accessed via the <code>get</code> function, which returns the queried value if it exists, or <code>nil</code> if it doesn't:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">get</span> #{<span class="pl-c1">:a</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">:b</span>} <span class="pl-c1">:b</span>)
<span class="pl-c">;=&gt; :b</span>

(<span class="pl-en">get</span> #{<span class="pl-c1">:a</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">:b</span>} <span class="pl-c1">:k</span>)
<span class="pl-c">;=&gt; nil</span></pre></div>

<p><strong>Searching a sequence for any of multiple items using a set and <code>some</code></strong></p>

<p>The <code>some</code> function takes a predicate and a sequence. It applies the predicate to each element in turn, returning the first <em>truthy</em> value returned by the predicate or else <code>nil</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">some</span> #{<span class="pl-c1">:b</span>} [<span class="pl-c1">:a</span> <span class="pl-c1">1</span> <span class="pl-c1">:b</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; :b</span>

(<span class="pl-en">some</span> #{<span class="pl-c1">1</span> <span class="pl-c1">:b</span>} [<span class="pl-c1">:a</span> <span class="pl-c1">1</span> <span class="pl-c1">:b</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; 1</span></pre></div>

<p>Using a set as the predicate supplied to <code>some</code> allows you to check whether any of the truthy values in the set are contained within the given sequence. This is a frequently used Clojure idiom for searching for containment within a sequence.</p>

<p>The key to understanding how sets determine whether an element is discrete lies in one simple statement: Given two elements, evaluating as equal, a set will contain only one, independent of concrete types:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> s #{[<span class="pl-c1">1</span> <span class="pl-c1">2</span>] (<span class="pl-c1">1</span> <span class="pl-c1">2</span>)})  <span class="pl-c">;vector and list with the same items are considered equal</span>

<span class="pl-c">;=&gt; IllegalArgumentException Duplicate key: (1 2)</span>
<span class="pl-c">;=&gt; clojure.lang.PersistentHashSet.createWithCheck (PersistentHashSet.java:68)</span></pre></div>

<p><strong>Sorted sets</strong></p>

<p>To ask for elements in a sorted order:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">sort</span> #{<span class="pl-c1">2</span> <span class="pl-c1">4</span> <span class="pl-c1">1</span>})
<span class="pl-c">;=&gt; (1 2 4)</span></pre></div>

<p>As long as the arguments to the <code>sorted-set</code> function are mutually comparable, you'll receive a sorted set. Otherwise an exception is thrown:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">sorted-set</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span> <span class="pl-c1">:a</span>)
<span class="pl-c">;=&gt; #{:a :b :c}</span>

(<span class="pl-en">sorted-set</span> [<span class="pl-c1">3</span> <span class="pl-c1">4</span>] [<span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; #{[1 2] [3 4]}</span>

(<span class="pl-en">sorted-set</span> <span class="pl-c1">:b</span> <span class="pl-c1">2</span> <span class="pl-c1">:c</span>)

<span class="pl-c">;=&gt; ClassCastException clojure.lang.Keyword cannot be cast to java.lang.Number</span>
<span class="pl-c">;=&gt; clojure.lang.Util.compare (Util.java:152)</span></pre></div>

<p>You can use your own comparator with <code>sorted-set-by</code> function.</p>

<p><strong>Containment</strong></p>

<p><code>contains?</code> checks for <strong>existence of a key</strong> in a collection:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">contains?</span> #{<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>} <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; true</span></pre></div>

<p>Many newcomers to Clojure expect <code>contains?</code> to behave the same as Java's <code>java.util.Collection#contains</code> method, but it doesn't:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">contains?</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">4</span> <span class="pl-c1">3</span>] <span class="pl-c1">4</span>)
<span class="pl-c">;=&gt; false</span></pre></div>

<p>Since <code>contains?</code> looks for existence of a key it shouldn't work with sets, but it does. That is due to the fact that sets are implemented as maps with the same element as the <em>key</em> and <em>value</em> with an additional check for containment before insertion.</p>

<h3>
<a id="clojureset-namespace" class="anchor" href="#clojureset-namespace" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>clojure.set</code> namespace</h3>

<p><code>clojure.set/intersection</code> function works as you might expect. Given two sets, it returns a set of the common elements. Given <em>n</em> sets, it'll incrementally return the intersection of resulting sets and the next set:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">clojure.set/intersection</span> #{<span class="pl-c1">:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span>} #{<span class="pl-c1">:d</span> <span class="pl-c1">:c</span> <span class="pl-c1">:b</span>})
<span class="pl-c">;=&gt; #{:b :c}</span>

(<span class="pl-en">clojure.set/intersection</span> #{<span class="pl-c1">:a</span> <span class="pl-c1">:e</span> <span class="pl-c1">:i</span> <span class="pl-c1">:o</span> <span class="pl-c1">:u</span>}
                          #{<span class="pl-c1">:a</span> <span class="pl-c1">:u</span> <span class="pl-c1">:r</span>}
                          #{<span class="pl-c1">:r</span> <span class="pl-c1">:u</span> <span class="pl-c1">:s</span>})
<span class="pl-c">;=&gt; #{:u}</span></pre></div>

<p><code>clojure.set/union</code> works as expected.<br>
<code>clojure.set/difference</code> "removes" all the elements from the first set that are also present in the second set (known as <em>relative complement</em>).</p>

<p><code>conj</code> "adds" an element to the set:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">conj</span> #{<span class="pl-c1">:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span>} <span class="pl-c1">:d</span>)
<span class="pl-c">;=&gt; #{:a :c :b :d}</span></pre></div>

<p><code>disj</code> "removes" an element:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">disj</span> #{<span class="pl-c1">1</span> <span class="pl-c1">2</span>} <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; #{1}</span></pre></div>

<p>You can make a set out of any other collection with <code>set</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">set</span> [<span class="pl-c1">2</span> <span class="pl-c1">5</span> <span class="pl-c1">1</span>])
<span class="pl-c">;=&gt; #{1 2 5}</span></pre></div>

<h2>
<a id="maps" class="anchor" href="#maps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Maps</h2>

<p>Map is an unsorted, associative <em>key/value</em> structure (associates keys with values).
Maps are represented with curly braces <code>{...}</code> filled by alternating <em>key/value</em> pairs, with or without commas:</p>

<div class="highlight highlight-clj"><pre>{<span class="pl-c1">:name</span> <span class="pl-s"><span class="pl-pds">"</span>luka<span class="pl-pds">"</span></span>, <span class="pl-c1">:weight</span> <span class="pl-c1">3</span> <span class="pl-c1">:color</span> <span class="pl-s"><span class="pl-pds">"</span>white<span class="pl-pds">"</span></span>}   <span class="pl-c">;notice missing comma</span>
<span class="pl-c">;=&gt; {:weight 3, :name "luka", :color "white"}</span></pre></div>

<p>We can look up the <em>value</em> by <em>key</em> with <code>get</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">get</span> {<span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>meow<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>dog<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>woof<span class="pl-pds">"</span></span>} <span class="pl-s"><span class="pl-pds">"</span>cat<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; "meow"</span></pre></div>

<p><code>get</code> can also take a default value to return instead of <code>nil</code>, if the key doesn’t exist:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">get</span> {<span class="pl-c1">:k</span> <span class="pl-c1">:v</span>} <span class="pl-c1">:w</span> <span class="pl-c1">:default</span>)
<span class="pl-c">;=&gt; :default</span></pre></div>

<p>Maps can be used as verbs, directly:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">{"a"</span> <span class="pl-c1">12</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-c1">24</span>} <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)  <span class="pl-c">;maps are functions of their keys</span>
<span class="pl-c">;=&gt; 24</span></pre></div>

<p>Keywords can also be used as verbs, which look themselves up:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-c1">:raccoon</span> {<span class="pl-c1">:weasel</span> <span class="pl-s"><span class="pl-pds">"</span>queen<span class="pl-pds">"</span></span>, <span class="pl-c1">:raccoon</span> <span class="pl-s"><span class="pl-pds">"</span>king<span class="pl-pds">"</span></span>})
<span class="pl-c">;=&gt; "king"</span></pre></div>

<p>In addition to literal syntax, hash maps can be created with the <code>hash-map</code> function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">hash-map</span> <span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>, <span class="pl-c1">:c</span> <span class="pl-c1">3</span>, <span class="pl-c1">:d</span> <span class="pl-c1">4</span>, <span class="pl-c1">:e</span> <span class="pl-c1">5</span>)
<span class="pl-c">;=&gt; {:a 1, :c 3, :b 2, :d 4, :e 5}</span></pre></div>

<p>Maps support heterogeneous keys, which means that keys can be of any type and each key can be of a different type:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [m {<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span> :b, [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] <span class="pl-s"><span class="pl-pds">"</span>4 5 6<span class="pl-pds">"</span></span>}]
  [(<span class="pl-en">get</span> m <span class="pl-c1">:a</span>) (<span class="pl-en">get</span> m [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])])
<span class="pl-c">;=&gt; [1 "4 5 6"]</span>

<span class="pl-c">;;which can also be written without 'get', using map as a function of its keys:</span>
(<span class="pl-k">let</span> [m {<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">1</span> :b, [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] <span class="pl-s"><span class="pl-pds">"</span>4 5 6<span class="pl-pds">"</span></span>}]
  [(<span class="pl-en">m</span> <span class="pl-c1">:a</span>) (<span class="pl-en">m</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])])
<span class="pl-c">;=&gt; [1 "4 5 6"]</span></pre></div>

<p>Providing a map to a <code>seq</code> function returns a sequence of map entries:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">seq</span> {<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>})
<span class="pl-c">;=&gt; ([:a 1] [:b 2])   ;returns key/value pairs contained in vectors</span></pre></div>

<p>A new hash map can be created idiomatically using <code>into</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">into</span> {} [[<span class="pl-c1">:a</span> <span class="pl-c1">1</span>] [<span class="pl-c1">:b</span> <span class="pl-c1">2</span>]])
<span class="pl-c">;=&gt; {:a 1, :b 2}</span>

<span class="pl-c">;;even if pairs aren't vectors, they can easily be made to be</span>
<span class="pl-c">;;here, the map function, that has nothing to do with map-the-data-structure,</span>
<span class="pl-c">;;applies 'vec' to all the elements:</span>
(<span class="pl-en">into</span> {} (<span class="pl-en">map</span> vec '[(<span class="pl-c1">:a</span> <span class="pl-c1">1</span>) (<span class="pl-c1">:b</span> <span class="pl-c1">2</span>)]))
<span class="pl-c">;=&gt; {:a 1, :b 2}</span></pre></div>

<p>If the key/value pairs are laid out in a sequence consecutively, your pairs don't even have to be explicitly grouped. You can use <code>apply</code> to create a hash map:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">apply</span> hash-map [<span class="pl-c1">:a</span> <span class="pl-c1">1</span> <span class="pl-c1">:b</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; {:a 1, :b 2}</span></pre></div>

<p>Another idiomatic way to build a map is to use <code>zipmap</code> to "zip" together two sequences, the first of which contains keys and the second one values:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">zipmap</span> [<span class="pl-c1">:a</span> <span class="pl-c1">:b</span>] [<span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; {:b 2, :a 1}</span></pre></div>

<p><code>assoc</code> "adds" an element to a map: </p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">assoc</span> {<span class="pl-c1">:bolts</span> <span class="pl-c1">1088</span>} <span class="pl-c1">:camshafts</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; {:camshafts 3, :bolts 1088}</span></pre></div>

<p><code>assoc</code> adds keys if they are not present, and replaces values if they are already there. If you associate a value onto <code>nil</code>, it creates a new map:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">assoc</span> <span class="pl-c1">nil</span> <span class="pl-c1">5</span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; {5 2}</span></pre></div>

<p><code>merge</code> yields a map containing all the elements of all given maps, preferring the values from later ones:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">merge</span> {<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>} {<span class="pl-c1">:b</span> <span class="pl-c1">3</span>, <span class="pl-c1">:c</span> <span class="pl-c1">4</span>})
<span class="pl-c">;=&gt; {:c 4, :a 1, :b 3}</span></pre></div>

<p>Remove map element with <code>dissoc</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">dissoc</span> {<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>, <span class="pl-c1">:c</span> <span class="pl-c1">4</span>} <span class="pl-c1">:c</span>)
<span class="pl-c">;=&gt; {:a 1, :b 2}</span></pre></div>

<p><strong>Sorted maps</strong></p>

<p>The function <code>sorted-map</code> builds a map sorted by the comparison of its keys:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">sorted-map</span> <span class="pl-c1">:b</span> <span class="pl-c1">1</span> <span class="pl-c1">:a</span> <span class="pl-c1">2</span> <span class="pl-c1">:c</span> <span class="pl-c1">0</span>)
<span class="pl-c">;=&gt; {:a 2, :b 1, :c 0}</span></pre></div>

<p>If you need alternative key ordering, or ordering for keys that are not naturally comparable, use <code>sorted-map-by</code>, which allows you to provide a comparison function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">sorted-map-by</span> #(<span class="pl-en">compare</span> %<span class="pl-c1">1</span> %<span class="pl-c1">2</span>) <span class="pl-s"><span class="pl-pds">"</span>bac<span class="pl-pds">"</span></span> <span class="pl-c1">9</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; {"abc" 2, "bac" 9}</span>

<span class="pl-c">;;Explanation:</span>
<span class="pl-c">;; by doing this:</span>
#(<span class="pl-en">compare</span> %<span class="pl-c1">1</span> %<span class="pl-c1">2</span>)   <span class="pl-c">;%1 stands for first parameter, in our case first map element</span>

<span class="pl-c">;; we declared an anonymous function inline, which is the same as writing:</span>
(<span class="pl-k">defn</span> <span class="pl-e">m-compare</span> [first second]
  (<span class="pl-en">compare</span> first second))

<span class="pl-c">;; and then passing that function to sorted-by-map:</span>
(<span class="pl-en">sorted-map-by</span> m-compare <span class="pl-s"><span class="pl-pds">"</span>bac<span class="pl-pds">"</span></span> <span class="pl-c1">9</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; {"abc" 2, "bac" 9}</span></pre></div>

<p>Sorted maps (and sets) support efficient jump to a particular key and walk forward or backward from there through the collection. This is where <code>subseq</code> and <code>rsubseq</code> come in:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">sm</span> (<span class="pl-en">sorted-map</span> <span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>, <span class="pl-c1">:c</span> <span class="pl-c1">3</span>, <span class="pl-c1">:d</span> <span class="pl-c1">4</span>, <span class="pl-c1">:e</span> <span class="pl-c1">5</span>, <span class="pl-c1">:f</span> <span class="pl-c1">6</span>, <span class="pl-c1">:g</span> <span class="pl-c1">7</span>))

(<span class="pl-en">subseq</span> sm &gt; <span class="pl-c1">:e</span>)
<span class="pl-c">;=&gt; ([:f 6] [:g 7])</span>

(<span class="pl-en">subseq</span> sm &gt; <span class="pl-c1">:c</span> &lt; <span class="pl-c1">:f</span>)
<span class="pl-c">;=&gt; ([:d 4] [:e 5])</span></pre></div>

<p>There's one important difference in how sorted maps and sets handle numeric keys. A number can be represented by different types (<code>long</code>, <code>int</code>, <code>float</code>,...) and in a hash map, those types are preserved, while in a sorted map all those types are converted to the most precise one:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">assoc</span> {<span class="pl-c1">1</span> <span class="pl-c1">:int</span>} <span class="pl-c1">1.0</span> <span class="pl-c1">:float</span>)
<span class="pl-c">;=&gt; {1.0 :float, 1 :int}</span>

(<span class="pl-en">assoc</span> (<span class="pl-en">sorted-map</span> <span class="pl-c1">1</span> <span class="pl-c1">:int</span>) <span class="pl-c1">1.0</span> <span class="pl-c1">:float</span>)  <span class="pl-c">;only one is kept, since maps are unique</span>
<span class="pl-c">;=&gt; {1 :float}</span></pre></div>

<p>When we're adding an element to a sorted map (or set), Clojure uses equality to determine both, the sort order and key presence (remember, maps have unique keys).</p>

<p><strong>Array maps</strong></p>

<p>Array maps are used to guarantee that the order of insertions will be preserved (just like vectors and arrays do):</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">hash-map</span> <span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>, <span class="pl-c1">:c</span> <span class="pl-c1">3</span>)
{<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:c</span> <span class="pl-c1">3</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>}

(<span class="pl-en">array-map</span> <span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>, <span class="pl-c1">:c</span> <span class="pl-c1">3</span>)
{<span class="pl-c1">:a</span> <span class="pl-c1">1</span>, <span class="pl-c1">:b</span> <span class="pl-c1">2</span>, <span class="pl-c1">:c</span> <span class="pl-c1">3</span>}</pre></div>

<blockquote>
<p>Like vectors, any item in a map literal is evaluated before the result is stored in the map. Unlike vectors, the order in which they are evaluated isn't guaranteed.</p>
</blockquote>

<h2>
<a id="persistence-immutability-and-functional-programming" class="anchor" href="#persistence-immutability-and-functional-programming" aria-hidden="true"><span class="octicon octicon-link"></span></a>Persistence, immutability and functional programming</h2>

<p>We'll start this section by giving a couple of phrases that encapsulate Clojure's immutability principles.</p>

<blockquote>
<p>if two objects aren't equal forever, then they're technically never equal</p>

<p>there's a difference between a mutable object and a mutable reference. The default in Java is that there are references that may point to mutable data, but in Clojure, there are only mutable references</p>

<p>immutable objects are always thread safe (Brian Goetz)</p>
</blockquote>

<p><strong>Structural sharing</strong></p>

<div class="highlight highlight-clojure"><pre>(<span class="pl-k">def</span> <span class="pl-e">baselist</span> (<span class="pl-en">list</span> <span class="pl-c1">:barnabas</span> <span class="pl-c1">:adam</span>))

(<span class="pl-k">def</span> <span class="pl-e">lst1</span> (<span class="pl-en">cons</span> <span class="pl-c1">:willie</span> baselist))

(<span class="pl-k">def</span> <span class="pl-e">lst2</span> (<span class="pl-en">cons</span> <span class="pl-c1">:phoenix</span> baselist))

baselist
<span class="pl-c">;=&gt; (:barnabas :adam)                 ;baselist stays unchanged</span>

lst1
<span class="pl-c">;=&gt; (:willie :barnabas :adam)</span>

lst2
<span class="pl-c">;=&gt; (:phoenix :barnabas :adam)</span>

(<span class="pl-en">=</span> (<span class="pl-en">next</span> lst1) (<span class="pl-en">next</span> lst2))           <span class="pl-c">;they are not only equal</span>
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">identical?</span> (<span class="pl-en">next</span> lst1) (<span class="pl-en">next</span> lst2))  <span class="pl-c">;but also the same underlying object</span>
<span class="pl-c">;=&gt; true</span></pre></div>

<p>You can think of <code>baselist</code> as a common historical version of <code>lst1</code> and <code>lst2</code>, but it's also the shared part of both lists. Not only are the <code>next</code> parts of both lists equal, they are identical (the same instance in memory).</p>

<p>Unlike lists, vectors and maps allow changes anywhere in the collection, not just on one end. This is made possible by the underlying data structure that those collection types are built upon - a tree.</p>

<p>A tree allows interior changes and still maintains shared structure between different versions/changes.</p>

<p>To demonstrate how <em>structural sharing</em> works, we'll build a simple tree, where each node will have three fields: a value, a left branch and a right branch:</p>

<div class="highlight highlight-clojure"><pre>{<span class="pl-c1">:val</span> <span class="pl-c1">50</span>, <span class="pl-c1">:L</span> nil, <span class="pl-c1">:R</span> <span class="pl-c1">nil</span>}</pre></div>

<p>Our empty tree will be represented by <code>nil</code> and the map above will represent that empty tree after a single node (with value <code>50</code>) has been added.</p>

<p>Let's start slowly. To handle just this initial case of adding a single node to an empty tree, we'll write <code>xconj</code> function like this:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">xconj</span> [t v]     <span class="pl-c">;add item with value 'v' to tree 't'</span>
  (<span class="pl-k">cond</span>
    (<span class="pl-en">nil?</span> t) {<span class="pl-c1">:val</span> v, <span class="pl-c1">:L</span> nil, <span class="pl-c1">:R</span> <span class="pl-c1">nil</span>})) <span class="pl-c">;if t is nil this will be the first node (root)</span>

(<span class="pl-en">xconj</span> <span class="pl-c1">nil</span> <span class="pl-c1">50</span>)
<span class="pl-c">;=&gt; {:val 50, :L nil, :R nil}</span></pre></div>

<p>OK, that works, but let's not start sucking each others' dicks just yet (<sup>TM</sup>Mr Wolf). We need to handle the case of adding an item to a non-empty tree.</p>

<p>So our tree doesn't even look like a tree yet:</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/UnbalancedBinaryTree-01.png" alt="{:val 50, :L nil, :R nil}" title="Unbalanced binary tree with a single node" width="222px"></p>

<p><code>:L</code> and <code>:R</code> are <code>nil</code>, so, for the sake of simplicity, we'll just make a rule that if an element does not point to some other element, it means it is <code>nil</code>. Presented this way, our tree looks like a piece of crap:</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/UnbalancedBinaryTree-02.png" alt="{:val 50, :L nil, :R nil}" title="Unbalanced binary tree with a single node" width="133px"></p>

<p>When adding a node to a non-empty tree, in order to keep the tree sorted, we must follow a simple rule: <em>the value of any node in our tree must be greater than its left child and smaller or equal to its right child.</em>  </p>

<p>So, in order to honor that rule, we need to compare the value being added first with the root, then with other nodes, down the tree, until we find the appropriate place for it.  </p>

<p>Let's try adding a couple of elements. How would we add value <code>40</code> to our tree?</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/UnbalancedBinaryTree-03.png" alt="{:val 50, :L nil, :R nil}" title="Unbalanced binary tree with a single node" width="280px"></p>

<p>Now that you saw this crucial image, take a look at the next one (let's keep our <code>nil</code>s a bit longer, it will be easier to reason about the algorithm):</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/UnbalancedBinaryTree-04.png" alt="{:val 50, :L nil, :R nil}" title="Unbalanced binary tree with a single node" width="133px"></p>

<p>How in earth did element <code>40</code> ended up there?</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">xconj</span> [t v]
  (<span class="pl-k">cond</span>
    (<span class="pl-en">nil?</span> t) {<span class="pl-c1">:val</span> v, <span class="pl-c1">:L</span> nil, <span class="pl-c1">:R</span> <span class="pl-c1">nil</span>}   <span class="pl-c">;does tree exist?</span>
    (<span class="pl-en">&lt;</span> v (<span class="pl-c1">:val</span> t))              <span class="pl-c">;if v is smaller than the current item's value</span>
          {<span class="pl-c1">:val</span> (<span class="pl-c1">:val</span> t),       <span class="pl-c">;make new item whose value is the value of current item</span>
           <span class="pl-c1">:L</span> (<span class="pl-en">xconj</span> (<span class="pl-c1">:L</span> t) v), <span class="pl-c">;point :L to new tree by calling xconj on tree's :L child</span>
           <span class="pl-c1">:R</span> (<span class="pl-c1">:R</span> t)}           <span class="pl-c">;point :R to current item's :R</span>
    <span class="pl-c1">:else</span> {<span class="pl-c1">:val</span> (<span class="pl-c1">:val</span> t)
           <span class="pl-c1">:L</span> (<span class="pl-c1">:L</span> t)
           <span class="pl-c1">:R</span> (<span class="pl-en">xconj</span> (<span class="pl-c1">:R</span> t) v)}
   ))


(<span class="pl-k">defn</span> <span class="pl-e">xseq</span> [t]
  (<span class="pl-k">when</span> t
    (<span class="pl-en">concat</span> (<span class="pl-en">xseq</span> (<span class="pl-c1">:L</span> t)) [(<span class="pl-c1">:val</span> t)] (<span class="pl-en">xseq</span> (<span class="pl-c1">:R</span> t)))))

<span class="pl-c">;;what is 'cond'?</span>
(<span class="pl-en">doc</span> <span class="pl-k">cond</span>)
<span class="pl-c">;=&gt; -------------------------</span>
<span class="pl-c">;=&gt; clojure.core/cond</span>
<span class="pl-c">;=&gt; ([&amp; clauses])</span>
<span class="pl-c">;=&gt; Macro</span>
<span class="pl-c">;=&gt;   Takes a set of test/expr pairs. It evaluates each test one at a</span>
<span class="pl-c">;=&gt;   time.  If a test returns logical true, cond evaluates and returns</span>
<span class="pl-c">;=&gt;   the value of the corresponding expr and doesn't evaluate any of the</span>
<span class="pl-c">;=&gt;   other tests or exprs. (cond) returns nil.</span></pre></div>

<p>This is how our tree looks like:</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/UnbalancedBinaryTree.png" alt="Unbalanced binary tree" title="Unbalanced binary tree" width="300px"></p>

<p>This is how our tree would look like if it was balanced. Compare number of hops needed to find value <code>20</code>.</p>

<p><img src="https://github.com/mbonaci/clojure/raw/master/resources/BalancedBinaryTree.png" alt="Balanced binary tree" title="Balanced binary tree" width="510px"></p>

<blockquote>
<p>persistent collections are immutable, in-memory (not on-disk) collections that allow you to preserve historical versions of their state.</p>
</blockquote>

<p>Since arrays are mutable, any changes happen in-place:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">ds</span> (<span class="pl-en">into-array</span> [<span class="pl-c1">:frane</span> <span class="pl-c1">:luka</span> <span class="pl-c1">:glupaca</span>]))  <span class="pl-c">;mutable</span>
<span class="pl-c">;=&gt; #'mbo/ds</span>

<span class="pl-c">;; btw Glupaca is the name of our cat (which means something like "stupid women")</span>

(<span class="pl-en">seq</span> ds)     <span class="pl-c">;only for nice REPL printout</span>
<span class="pl-c">;=&gt; (:frane :luka :glupaca)</span>

(<span class="pl-en">aset</span> ds <span class="pl-c1">2</span> <span class="pl-c1">:suzi</span>)   <span class="pl-c">;replace third element of the array</span>
<span class="pl-c">;=&gt; :suzi</span>

(<span class="pl-en">seq</span> ds)
<span class="pl-c">;=&gt; (:frane :luka :suzi)</span></pre></div>

<p>Using one of Clojure's persistent data structures shows the difference:</p>

<div class="highlight highlight-clj"><pre>mbo=&gt; (<span class="pl-k">def</span> <span class="pl-e">ds</span> [<span class="pl-c1">:frane</span> <span class="pl-c1">:luka</span> <span class="pl-c1">:suzi</span>])  <span class="pl-c">;init persistent collection</span>
<span class="pl-c">;=&gt; #'mbo/ds</span>

ds            <span class="pl-c">;print ds to REPL</span>
<span class="pl-c">;=&gt; [:frane :luka :suzi]</span>

(<span class="pl-k">def</span> <span class="pl-e">ds8</span> (<span class="pl-en">replace</span> {<span class="pl-c1">:suzi</span> <span class="pl-c1">:glupaca</span>} ds))   <span class="pl-c">;replace third element and bind the</span>
<span class="pl-c">;=&gt; #'mbo/ds8                             ;new collection to ds8</span>

ds            <span class="pl-c">;ds did not change</span>
<span class="pl-c">;=&gt; [:frane :luka :suzi]</span>

ds8           <span class="pl-c">;the newly created collection</span>
<span class="pl-c">;=&gt; [:frane :luka :glupaca]</span></pre></div>

<h1>
<a id="symbols-1" class="anchor" href="#symbols-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols</h1>

<p>Closest thing to a variable in Clojure. Primarily used to provide a name for a given value, i.e. to refer to function parameters, local variables, globals, and Java classes.</p>

<p>Unlike keywords, symbols are not unique based solely on their names:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">identical?</span> 'node 'node)
<span class="pl-c">;=&gt; false</span>

<span class="pl-c">;; identical? returns true only if symbols are the same object</span>
(<span class="pl-k">let</span> [x 'node y x] (<span class="pl-en">identical?</span> x y))
<span class="pl-c">;=&gt; true</span></pre></div>

<p>Each <code>node</code> symbol is a discrete object that only happens to share a name. Though name is the basis for symbol equality:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">=</span> 'node 'node)
<span class="pl-c">;=&gt; true</span>

(<span class="pl-en">name</span> 'node)
<span class="pl-c">;=&gt; "node"</span></pre></div>

<p>We can define a meaning for a symbol within a specific expression, using <code>let</code>.
The <code>let</code> expression first <strong>takes a vector of bindings</strong>: alternating symbols and values that those symbols are bound to within the remainder of the expression.  </p>

<p>“Let the symbol <code>cats</code> be <code>5</code>, and construct a string composed of <code>"I have "</code>, <code>cats</code>, and <code>" cats"</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [cats <span class="pl-c1">5</span>] (<span class="pl-en">str</span> <span class="pl-s"><span class="pl-pds">"</span>I have <span class="pl-pds">"</span></span> cats <span class="pl-s"><span class="pl-pds">"</span> cats.<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; "I have 5 cats."</span></pre></div>

<p>Let bindings, also called <strong>locals</strong>, apply only within the <code>let</code> expression itself. They also override any existing definitions for symbols at that point in the program. For example, we can redefine addition to mean subtraction, for the duration of a <code>let</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [+ -] (<span class="pl-en">+</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; -1</span></pre></div>

<p>That definition does not apply outside the <code>let</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">+</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; 5</span></pre></div>

<p>We can also provide multiple bindings. Since Clojure doesn’t care about spacing, alignment, or newlines, we’ll write this on multiple lines, for clarity:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [person <span class="pl-s"><span class="pl-pds">"</span>joseph<span class="pl-pds">"</span></span>
      num-cats <span class="pl-c1">186</span>]
  (<span class="pl-en">str</span> person <span class="pl-s"><span class="pl-pds">"</span> has <span class="pl-pds">"</span></span> num-cats <span class="pl-s"><span class="pl-pds">"</span> cats!<span class="pl-pds">"</span></span>))  <span class="pl-c">;the body</span>
<span class="pl-c">;=&gt; "joseph has 186 cats!"</span></pre></div>

<p>When multiple bindings are given, they are evaluated in order. Later bindings can use previous bindings:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [cats <span class="pl-c1">3</span>
      legs (<span class="pl-en">*</span> <span class="pl-c1">4</span> cats)]
  (<span class="pl-en">str</span> legs <span class="pl-s"><span class="pl-pds">"</span> legs all together<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; "12 legs all together"</span></pre></div>

<blockquote>
<p>a symbol whose name is prefixed with a namespace, followed by a slash, is called <strong>fully qualified symbol</strong>:</p>
</blockquote>

<div class="highlight highlight-clj"><pre>clojure.core/map
<span class="pl-c">;=&gt; #&lt;core$map clojure.core$map@2a0406c4&gt;</span>

clojure.set/union
<span class="pl-c">;=&gt; #&lt;set$union clojure.set$union@1be2bcc8&gt;</span></pre></div>

<p>The body is sometimes described as an <em>implicit do</em> (see <a href="#blocks">blocks bellow</a>) because it follows the same rules: you may include any number of expressions and all will be evaluated, but only the value of the last one is returned.</p>

<p>Because they’re immutable, <em>locals</em> can’t be used to accumulate results. Instead,
you'd use a high level function or loop/recur form.</p>

<p>To summarize, <code>let</code> defines the meaning of symbols within an expression. When Clojure evaluates a <code>let</code>, it replaces all occurrences of those symbols in the rest of the <code>let</code> expression with their corresponding values, then evaluates the rest of the expression.</p>

<p><strong>Metadata</strong></p>

<p>Clojure allows the attachment of metadata to various objects, including symbols. <code>with-meta</code> function takes an object and a map and returns another object of the same type with the metadata attached:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [x (<span class="pl-en">with-meta</span> 'node {<span class="pl-c1">:js</span> <span class="pl-c1">true</span>})    <span class="pl-c">;attach :js to 'node and assign to x</span>
      y (<span class="pl-en">with-meta</span> 'node {<span class="pl-c1">:js</span> <span class="pl-c1">false</span>})]
  [(<span class="pl-en">=</span> x y)            <span class="pl-c">;true because they both hold the same symbol, 'node</span>
   (<span class="pl-en">identical?</span> x y)   <span class="pl-c">;false because they are different instances</span>
   (<span class="pl-en">meta</span> x)
   (<span class="pl-en">meta</span> y)])
<span class="pl-c">;=&gt; [true false {:js true} {:js false}]</span></pre></div>

<p><strong>Symbols and namespaces</strong></p>

<p>Like keywords, symbols don't belong to any specific namespace:</p>

<div class="highlight highlight-clj"><pre>user=&gt; (<span class="pl-k">ns</span> <span class="pl-e">what-where</span>)
<span class="pl-c">;=&gt; nil</span>

what-where=&gt; (<span class="pl-k">def</span> <span class="pl-e">one-simbol</span> '<span class="pl-e">where-is-it</span>)
<span class="pl-c">;=&gt; #'what-where/one-simbol</span>

what-where=&gt; one-simbol
<span class="pl-c">;=&gt; where-is-it</span>

what-where=&gt; (<span class="pl-en">resolve</span> 'one-simbol)
<span class="pl-c">;=&gt; #'what-where/one-simbol  ;looks like namespace-qualified symbol</span>
                             <span class="pl-c">;but it's just a characteristic of symbol evaluation</span>

what-where=&gt; `one-symbol   <span class="pl-c">;back tick</span>
<span class="pl-c">;=&gt; what-where/one-symbol</span></pre></div>

<h1>
<a id="functions" class="anchor" href="#functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Functions</h1>

<p>Functions are a first-class type in Clojure. They can be used the same as any value (stored in Vars, held in collections, passed as arguments and returned as a result of other functions).</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [x] (<span class="pl-en">+</span> x <span class="pl-c1">1</span>))</pre></div>

<p>We can’t actually evaluate this program, because there’s no value for <code>x</code> yet. It could be <code>1</code>, or <code>4</code>, or <code>1453</code>. We say that <code>x</code> is <em>unbound</em>, because it has no binding to a particular value. This is the nature of the <strong>function</strong>: an expression with unbound symbols.</p>

<p>Function definition:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">fn</span> [x] (<span class="pl-en">+</span> x <span class="pl-c1">1</span>))
<span class="pl-c">;=&gt; #&lt;user$eval1487$fn__1488 user$eval1487$fn__1488@6b7d28db&gt;</span></pre></div>

<p>Named function definition:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [twice (<span class="pl-k">fn</span> [x] (<span class="pl-en">*</span> <span class="pl-c1">2</span> x))]
   (<span class="pl-en">+</span> (<span class="pl-en">twice</span> <span class="pl-c1">1</span>)
   (<span class="pl-en">twice</span> <span class="pl-c1">3</span>)))
<span class="pl-c">;=&gt; 8</span></pre></div>

<p><code>let</code> bindings describe a similar relationship, but with a specific set of values for those arguments. <code>let</code> is evaluated immediately, whereas <code>fn</code> is evaluated later, when bindings are provided.</p>

<h2>
<a id="vars" class="anchor" href="#vars" aria-hidden="true"><span class="octicon octicon-link"></span></a>Vars</h2>

<p>Once a <code>let</code> is defined, there’s no way to change it. If we want to redefine symbols for everyone, even code that we didn’t write, we need a new construct, a mutable variable.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">cats</span> <span class="pl-c1">5</span>)
<span class="pl-c">;=&gt; #'user/cats</span>

(<span class="pl-en">type</span> #'user/cats)
<span class="pl-c">;=&gt; clojure.lang.Var</span>

cats
<span class="pl-c">;=&gt; 5</span></pre></div>

<p><code>def</code> defines a type of value we haven’t seen before: a <em>Var</em>. <em>Vars</em>, like symbols, are references to other values. When evaluated, a <em>Var</em> is replaced by its corresponding value.  </p>

<p><code>def</code> also binds the symbol <code>cats</code> (and its globally qualified equivalent <code>user/cats</code>) to that <em>Var</em>.  </p>

<p>The symbol <code>inc</code> points to the <em>Var</em> <code>#'inc</code>, which in turn points to the function <code>#&lt;core$inc clojure.core$inc@16bc0b3c&gt;</code>.  </p>

<p>We can see the intermediate Var with <code>resolve</code>:</p>

<div class="highlight highlight-clj"><pre>'inc     <span class="pl-c">;symbol</span>
<span class="pl-c">;=&gt; inc</span>

(<span class="pl-en">resolve</span> 'inc)
<span class="pl-c">;=&gt; #'clojure.core/inc    ;variable</span>

(<span class="pl-en">eval</span> 'inc)
<span class="pl-c">;=&gt; #&lt;core$inc clojure.core$inc@d6206b5&gt;  ;value</span></pre></div>

<p>Why those two levels of indirection? Unlike with symbol, we can change the meaning of a Var for everyone, globally, at any time.  </p>

<p>Vars don't require a value. Instead we can just declare them and, by doing so, defer the binding of value.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> y)
<span class="pl-c">;=&gt; #'user/y</span>

<span class="pl-c">;; if we try to use it:</span>
y

<span class="pl-c">;=&gt; java.lang.IllegalStateException: Var user/y is unbound</span></pre></div>

<h2>
<a id="named-functions" class="anchor" href="#named-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Named functions</h2>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">half</span> 
  (<span class="pl-k">fn</span> [number] (<span class="pl-en">/</span> number <span class="pl-c1">2</span>)))
<span class="pl-c">;=&gt; #'user/half</span>

(<span class="pl-en">half</span> <span class="pl-c1">8</span>)
<span class="pl-c">;=&gt; 4</span></pre></div>

<p>Creating a function and binding it to a variable is so common that it has its own form: <code>defn</code>, which is a <em>macro</em> that is short for <code>def fn</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">half</span> [number] (<span class="pl-en">/</span> number <span class="pl-c1">2</span>))
<span class="pl-c">;=&gt; #'user/half</span>

(<span class="pl-en">half</span> <span class="pl-c1">8</span>)
<span class="pl-c">;=&gt; 4</span></pre></div>

<p>Functions don’t have to take an argument. We’ve seen functions which take zero arguments, like <code>(+)</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">half</span> [] <span class="pl-c1">1/2</span>)
<span class="pl-c">;=&gt; #'user/half</span></pre></div>

<p>But if we try to use our earlier form with one argument, Clojure complains that the <em>arity</em> (the number of arguments to a function) is incorrect:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">half</span> <span class="pl-c1">8</span>)

<span class="pl-c">;=&gt; ArityException Wrong number of args (1) passed to: user$half</span>
<span class="pl-c">;=&gt; clojure.lang.AFn.throwArity (AFn.java:437)</span></pre></div>

<p>To handle multiple arities, functions have an alternate form, instead of an argument vector and a body, one provides a series of lists, each of which starts with an argument vector, followed by the body:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">half</span>
   ([] <span class="pl-c1">1/2</span>)
   ([x] (<span class="pl-en">/</span> x <span class="pl-c1">2</span>)))
<span class="pl-c">;=&gt; #'user/half</span>

(<span class="pl-en">half</span>)
<span class="pl-c">;=&gt; 1/2</span>

(<span class="pl-en">half</span> <span class="pl-c1">8</span>)
<span class="pl-c">;=&gt; 4</span></pre></div>

<p>Multiple arguments work just like you expect. Just specify an argument vector of two, or three, or however many arguments the function takes.<br>
Some functions can take any number of arguments. For that, Clojure provides <code>&amp;</code>, which slurps up all remaining arguments as a list:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">vargs</span> [x y &amp; more-args]
   {<span class="pl-c1">:x</span> x
    <span class="pl-c1">:y</span> y
    <span class="pl-c1">:more</span> more-args})
<span class="pl-c">;=&gt; #'user/vargs</span>

(<span class="pl-en">vargs</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>)
<span class="pl-c">;=&gt; {:x 1, :y 2, :more nil}</span>

(<span class="pl-en">vargs</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span> <span class="pl-c1">5</span>)
<span class="pl-c">;=&gt; {:x 1, :y 2, :more (3 4 5)}</span></pre></div>

<p><code>x</code> and <code>y</code> are mandatory, though there don’t have to be any remaining arguments.  </p>

<p>To keep track of what arguments a function takes, why the function exists, and what it does, we usually include a <strong>docstring</strong>. Docstrings help fill in the missing context around functions, to explain their assumptions, context, and purpose to the world:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">launch</span>
   <span class="pl-s"><span class="pl-pds">"</span>Launches a spacecraft into the given orbit by initiating a</span>
<span class="pl-s">    controlled on-axis burn. Does not automatically stage, but</span>
<span class="pl-s">    does vector thrust, if the craft supports it.<span class="pl-pds">"</span></span>
   [craft target-orbit]
   <span class="pl-s"><span class="pl-pds">"</span>OK, we don't know how to control spacecraft yet.<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; #'user/launch</span></pre></div>

<p>Docstrings are used to automatically generate documentation for a Clojure programs, but you can also access them from the <strong>REPL</strong> (The <code>user=&gt;</code> prompt refers to the top-level namespace of the default REPL):</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">doc</span> launch)
<span class="pl-c">;=&gt; -------------------------</span>
<span class="pl-c">;=&gt; user/launch</span>
<span class="pl-c">;=&gt; ([craft target-orbit])</span>
<span class="pl-c">;=&gt;   Launches a spacecraft into the given orbit by initiating a</span>
<span class="pl-c">;=&gt;    controlled on-axis burn. Does not automatically stage, but</span>
<span class="pl-c">;=&gt;    does vector thrust, if the craft supports it.</span>
<span class="pl-c">;=&gt; nil</span></pre></div>

<p><code>doc</code> tells us the full name of the function, the arguments it accepts, and its docstring. This information comes from the <code>launch</code> Var’s metadata, and is saved there by <code>defn</code>. We can inspect metadata directly with the <code>meta</code> function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">meta</span> #'launch)
<span class="pl-c">;=&gt; {:arglists ([craft target-orbit]), :ns #&lt;Namespace user&gt;, :name launch, :column 1,</span>
<span class="pl-c">;=&gt; :doc "Launches a spacecraft into the given orbit by initiating a\n   controlled </span>
<span class="pl-c">;=&gt; on-axis burn. Does not automatically stage, but\n   does vector thrust, if the </span>
<span class="pl-c">;=&gt; craft supports it.", :line 1, :file "/tmp/form-init523009510157887861.clj"}</span></pre></div>

<p>There’s some other juicy information in there, like the file the function was defined in and which line and column it started at, but that’s not particularly useful since we’re in the <em>REPL</em>, not a file. However, this does hint at a way to answer our motivating question: how does the <code>type</code> function work?</p>

<h2>
<a id="blocks" class="anchor" href="#blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blocks</h2>

<p>When you have a series or block of expressions that need to be treated as one, use <code>do</code>. All the expressions will be evaluated, but only the last one will be returned:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">do</span>
   <span class="pl-c1">6</span>
   (<span class="pl-en">+</span> <span class="pl-c1">5</span> <span class="pl-c1">4</span>)
   <span class="pl-c1">3</span>)
<span class="pl-c">;=&gt; 3</span></pre></div>

<p>The expressions <code>6</code> and <code>(+ 5 4)</code> are perfectly legal. The addition in <code>(+ 5 4)</code> is even done, but the value is thrown away, only the final expression <code>3</code> is returned</p>

<h2>
<a id="how-does-type-work" class="anchor" href="#how-does-type-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>How does <code>type</code> work?</h2>

<p><code>type</code>, like all functions, is a kind of object with its own unique type:</p>

<div class="highlight highlight-clj"><pre>type
<span class="pl-c">;=&gt; #&lt;core$type clojure.core$type@2761df2a&gt;</span>

(<span class="pl-en">type</span> type)
<span class="pl-c">;=&gt; clojure.core$type</span></pre></div>

<p>This tells us that <code>type</code> is a particular instance, at memory address <code>39bda9b9</code>, of the type <code>clojure.core$type</code>. 
<code>clojure.core</code> is a namespace which defines the fundamentals of the Clojure language, and <code>$type</code> tells us that it’s named type in that namespace. None of this is particularly helpful, though. Maybe we can find out more about the <code>clojure.core$type</code> by asking what its supertypes are:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">supers</span> (<span class="pl-en">type</span> type))
<span class="pl-c">;=&gt; #{java.io.Serializable java.lang.Runnable clojure.lang.AFunction </span>
<span class="pl-c">;=&gt; clojure.lang.IMeta clojure.lang.AFn java.lang.Object clojure.lang.IObj </span>
<span class="pl-c">;=&gt; java.util.Comparator clojure.lang.Fn java.util.concurrent.Callable </span>
<span class="pl-c">;=&gt; clojure.lang.IFn}</span></pre></div>

<p>This is a set of all the types that include <code>type</code>. We say that <code>type</code> is an instance of <code>clojure.lang.AFunction</code>, or that it implements or extends <code>java.util.concurrent.Callable</code>, and so on. Since it’s a member of <code>clojure.lang.IMeta</code> it has metadata, and since it’s a member of <code>clojure.lang.AFn</code>, it’s a function. Just to double check, let’s confirm that <code>type</code> is indeed a function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">fn?</span> type)
<span class="pl-c">;=&gt; true</span></pre></div>

<p><code>type</code> can take a single argument, which it calls <code>x</code>. If it has <code>:type</code> metadata, that’s what it returns. Otherwise, it returns the class of <code>x</code>. Let’s take a deeper look at <code>type</code>’s metadata for more clues:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">doc</span> type)
<span class="pl-c">;=&gt; -------------------------</span>
<span class="pl-c">;=&gt; clojure.core/type</span>
<span class="pl-c">;=&gt; ([x])</span>
<span class="pl-c">;=&gt;   Returns the :type metadata of x, or its Class if none</span>
<span class="pl-c">;=&gt; nil</span></pre></div>

<p>This function was first added to Clojure in version <code>1.0</code>, and is defined in the file <code>clojure/core.clj</code>, on line <code>3109</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">meta</span> #'type)
<span class="pl-c">;=&gt; {:ns #&lt;Namespace clojure.core&gt;, :name type, :arglists ([x]), :column 1, </span>
<span class="pl-c">;=&gt; :added "1.0", :static true, :doc "Returns the :type metadata of x, or its Class </span>
<span class="pl-c">;=&gt; if none", :line 3109, :file "clojure/core.clj"}</span></pre></div>

<p>We could go dig up the Clojure source code and read its definition there, or we could ask Clojure to do it for us. Aha! Here, at last, is how <code>type</code> works. It’s a function which takes a single argument <code>x</code>, and returns either <code>:type</code> from its metadata, or <code>(class x)</code>.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">source</span> type)
<span class="pl-c">;=&gt; (defn type </span>
<span class="pl-c">;=&gt;   "Returns the :type metadata of x, or its Class if none"</span>
<span class="pl-c">;=&gt;   {:added "1.0"</span>
<span class="pl-c">;=&gt;    :static true}</span>
<span class="pl-c">;=&gt;   [x]</span>
<span class="pl-c">;=&gt;   (or (get (meta x) :type) (class x)))</span>
<span class="pl-c">;=&gt; nil</span></pre></div>

<h1>
<a id="sequences" class="anchor" href="#sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequences</h1>

<p>A <strong>sequential</strong> collection is one that holds a series of values without reordering them.</p>

<p>A <strong>sequence</strong> is a sequential collection that represents a series of values that may or may not exist yet (may have concrete values, may be lazy or empty). Few composite types are actually <em>sequences</em>, though several such as vectors are <em>sequential</em>. All an object needs to do to be a sequence is to support two core functions, <code>first</code> and <code>rest</code></p>

<p>A <strong>seq</strong> is a simple API for navigating collections which consists of two functions, <code>first</code> and <code>rest</code></p>

<p>If two sequentials have the same values in the same order, <code>=</code> will return <code>true</code> for them, even if their concrete types are different:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] '(<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>))
<span class="pl-c">;=&gt; true</span></pre></div>

<p>Conversely, even if two collections have the same values in the same order, if one is a sequential collection and the other isn't, <code>=</code> will return <code>false</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">=</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] #{<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>})
<span class="pl-c">;=&gt; false</span></pre></div>

<p>If the collection is empty, <code>seq</code> always returns <code>nil</code> and never an empty sequence (that goes for all other functions that return a <code>seq</code>, e.g. <code>next</code>).</p>

<blockquote>
<p>Clojure classifies each composite data type into 3 partitions: <em>sequentials</em>, <em>maps</em> and <em>sets</em>. Everything that implements <code>java.util.List</code> is included in the sequential partition. Generally things that fall into other two partitions include set or map in their name</p>
</blockquote>

<p>Every collection type provides at least one kind of <code>seq</code> object for walking through its elements</p>

<h2>
<a id="recursion" class="anchor" href="#recursion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recursion</h2>

<p><code>cons</code>, makes a list beginning with the first argument, followed by all the elements in the second argument:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">cons</span> <span class="pl-c1">1</span> [<span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (1 2 3 4)</span></pre></div>

<p>Problem of incrementing all elements of a vector:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">inc-first</span> [nums]
   (<span class="pl-k">if</span> (<span class="pl-en">first</span> nums)
     <span class="pl-c">; If there's a first num, build a new list with cons</span>
     (<span class="pl-en">cons</span> (<span class="pl-en">inc</span> (<span class="pl-en">first</span> nums))
           (<span class="pl-en">rest</span> nums))
     <span class="pl-c">; If there's no first num, return an empty list</span>
     (<span class="pl-en">list</span>)))
<span class="pl-c">;=&gt; #'user/inc-first</span>

(<span class="pl-en">inc-first</span> [])
<span class="pl-c">;=&gt; ()</span>

(<span class="pl-en">inc-first</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; (2 2 3)</span></pre></div>

<p>What if we called our function on <code>rest</code>?</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">inc-all</span> [nums]
   (<span class="pl-k">if</span> (<span class="pl-en">first</span> nums)
     (<span class="pl-en">cons</span> (<span class="pl-en">inc</span> (<span class="pl-en">first</span> nums))
           (<span class="pl-en">inc-all</span> (<span class="pl-en">rest</span> nums)))
     (<span class="pl-en">list</span>)))
<span class="pl-c">;=&gt; #'user/inc-all</span>

(<span class="pl-en">inc-all</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (2 3 4 5)</span></pre></div>

<p>This technique is called <em>recursion</em>, and it is a fundamental principle in working with collections, sequences, trees, graphs or any problem which has small parts linked together. There are two key elements in a recursive program:</p>

<ul>
<li>Some part of the problem which has a known solution</li>
<li>A relationship which connects one part of the problem to the next</li>
</ul>

<p>Incrementing the elements of an empty list returns the empty list. This is our <strong>base case</strong>, the ground to build on. Our <strong>inductive case</strong>, also called the <em>recurrence relation</em>, is how we broke the problem up into incrementing the first number in the sequence, and incrementing all the numbers in the rest of the sequence. The <code>if</code> expression bound these two cases together into a single function, a function defined in terms of itself.
Let’s parameterize our <code>inc-all</code> function to use any transformation of its elements:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">transform-all</span> [f xs]
   (<span class="pl-k">if</span> (<span class="pl-en">first</span> xs)
     (<span class="pl-en">cons</span> (<span class="pl-en">f</span> (<span class="pl-en">first</span> xs))
           (<span class="pl-en">transform-all</span> f (<span class="pl-en">rest</span> xs)))
     (<span class="pl-en">list</span>)))
<span class="pl-c">;=&gt; #'user/transform-all</span>

(<span class="pl-en">transform-all</span> inc [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (2 3 4 5)</span></pre></div>

<h2>
<a id="loop" class="anchor" href="#loop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loop</h2>

<p>When using recursion, you sometimes want to loop back not to the top of the function, but to somewhere inside the function body.<br>
The <code>loop</code> acts exactly like <code>let</code> but provides a target for <code>recur</code> to jump to:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">sum-down-from</span> [initial-x]
   (<span class="pl-k">loop</span> [sum <span class="pl-c1">0</span>, x initial-x]
     (<span class="pl-k">if</span> (<span class="pl-en">pos?</span> x)
       (<span class="pl-k">recur</span> (<span class="pl-en">+</span> sum x) (<span class="pl-en">dec</span> x))
       sum)))
<span class="pl-c">;=&gt; #'user/sum-down-from</span></pre></div>

<p>Upon entering the <code>loop</code>, the locals <code>sum</code> and <code>x</code> are initialized (like in <code>let</code>). A <code>recur</code> always loops back to the closest enclosing <code>loop</code> or <code>fn</code>. The <code>loop</code> locals are rebound to the values given in <code>recur</code>.<br>
<code>recur</code> works only from the tail position.  </p>

<p><code>keyword</code> transforms a string to keyword:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">transform-all</span> keyword [<span class="pl-s"><span class="pl-pds">"</span>aa<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>bb<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>cc<span class="pl-pds">"</span></span>])
<span class="pl-c">;=&gt; (:aa :bb :cc)</span></pre></div>

<p>To wrap every element in a list:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">transform-all</span> list [<span class="pl-s"><span class="pl-pds">"</span>aa<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>bb<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>cc<span class="pl-pds">"</span></span>])
<span class="pl-c">;=&gt; (("aa") ("bb") ("cc"))</span></pre></div>

<p>We basically implemented <code>map</code> function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">map</span> inc [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (2 3 4 5)</span></pre></div>

<p>The function <code>map</code> relates one sequence to another. The type <code>map</code> relates keys to values. There is a deep symmetry between the two: maps are usually sparse, and the relationships between keys and values may be arbitrarily complex. The <code>map</code> function, on the other hand, usually expresses the same type of relationship, applied to a series of elements in a fixed order.</p>

<p>Clojure has a <em>special form</em> called <code>recur</code> that's specifically used for tail recursion:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">print-down-from</span> [x]
   (<span class="pl-k">when</span> (<span class="pl-en">pos?</span> x)  <span class="pl-c">;return when x is no longer positive</span>
     (<span class="pl-en">println</span> x)
     (<span class="pl-k">recur</span> (<span class="pl-en">dec</span> x))))
<span class="pl-c">;=&gt; #'user/print-down-from</span>

(<span class="pl-en">print-down-from</span> <span class="pl-c1">5</span>)
<span class="pl-c">;=&gt; 5</span>
<span class="pl-c">;=&gt; 4</span>
<span class="pl-c">;=&gt; 3</span>
<span class="pl-c">;=&gt; 2</span>
<span class="pl-c">;=&gt; 1</span>
<span class="pl-c">;=&gt; nil</span></pre></div>

<blockquote>
<p><code>when</code> is same as <code>if</code>, except it doesn't have the <code>else</code> part and it provides an implicit <code>do</code> in order to perform side-effects</p>
</blockquote>

<p>This is nearly identical to how you’d structure a while loop in an imperative language.One significant difference is that the value of <code>x</code> isn’t decremented somewhere in the body of the loop. Instead, a new value is calculated as a parameter to <code>recur</code>, which immediately does two things: rebinds <code>x</code> to the new value and returns control to the top of <code>print-down-from</code>.<br>
If the function has multiple arguments, the <code>recur</code> call must as well, just as if you were calling the function by name instead of using the <code>recur</code> special form. And just as with a function call, the expressions in the <code>recur</code> are evaluated in order first and only then bound to the function arguments simultaneously.</p>

<h2>
<a id="building-sequences" class="anchor" href="#building-sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Sequences</h2>

<p>We can use recursion to expand a single value into a sequence of values, each related by some function. For instance (<code>pos?</code> returns <code>true</code> if <code>num</code> is greater than zero, else <code>false</code>):</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">expand</span> [f x count]
   (<span class="pl-k">if</span> (<span class="pl-en">pos?</span> count)
     (<span class="pl-en">cons</span> x (<span class="pl-en">expand</span> f (<span class="pl-en">f</span> x) (<span class="pl-en">dec</span> count)))))
<span class="pl-c">;=&gt; #'user/expand</span>

(<span class="pl-en">expand</span> inc <span class="pl-c1">0</span> <span class="pl-c1">10</span>)
<span class="pl-c">;=&gt; (0 1 2 3 4 5 6 7 8 9)</span></pre></div>

<p>Our base case is <code>x</code> itself, followed by the sequence beginning with <code>(f x)</code>. That sequence in turn expands to <code>(f (f x))</code>, and then to <code>(f (f (f x)))</code>, and so on. Each time we call <code>expand</code>, we count down by one using <code>dec</code>. Once the <code>count</code> is zero, <code>if</code> returns <code>nil</code>, and evaluation stops.</p>

<p>Clojure has a more general form of this function, called <code>iterate</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take</span> <span class="pl-c1">10</span> (<span class="pl-en">iterate</span> inc <span class="pl-c1">0</span>))
<span class="pl-c">;=&gt; (0 1 2 3 4 5 6 7 8 9)</span></pre></div>

<p>Since this sequence is infinitely long, we’re using <code>take</code> to select only the first 10 elements. We can construct more complex sequences by using more complex functions:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take</span> <span class="pl-c1">10</span> (<span class="pl-en">iterate</span> (<span class="pl-k">fn</span> [x] (<span class="pl-k">if</span> (<span class="pl-en">odd?</span> x) (<span class="pl-en">+</span> <span class="pl-c1">1</span> x) (<span class="pl-en">/</span> x <span class="pl-c1">2</span>))) <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; (10 5 6 3 4 2 1 2 1 2)</span></pre></div>

<p><code>repeat</code> constructs a sequence where every element is the same:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take</span> <span class="pl-c1">10</span> (<span class="pl-en">repeat</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; ("a" "a" "a" "a" "a" "a" "a" "a" "a" "a")</span>

(<span class="pl-en">repeat</span> <span class="pl-c1">5</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; ("b" "b" "b" "b" "b")</span></pre></div>

<p><code>repeatedly</code> simply calls a function <code>(f)</code> to generate an infinite sequence of values, over and over again, without any relationship between elements. For an infinite sequence of random numbers:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">rand</span>)
<span class="pl-c">;=&gt; 0.6934524557647231</span>

(<span class="pl-en">rand</span>)
<span class="pl-c">;=&gt; 0.1355414232605504</span>

(<span class="pl-en">take</span> <span class="pl-c1">3</span> (<span class="pl-en">repeatedly</span> rand))
<span class="pl-c">;=&gt; (0.18806021884865332 0.5231673860825672 0.38244349544358525)</span></pre></div>

<p><code>range</code> generates a sequence of numbers between two points. 
<code>(range n)</code> gives <code>n</code> successive integers starting at 0. 
<code>(range n m)</code> returns integers from <code>n</code> to <code>m-1</code>. 
<code>(range n m step)</code> returns integers from <code>n</code> to <code>m</code>, separated by <code>step</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">range</span> <span class="pl-c1">5</span>)
<span class="pl-c">;=&gt; (0 1 2 3 4)</span>

(<span class="pl-en">range</span> <span class="pl-c1">5</span> <span class="pl-c1">8</span>)
<span class="pl-c">;=&gt; (5 6 7)</span>

(<span class="pl-en">range</span> <span class="pl-c1">5</span> <span class="pl-c1">25</span> <span class="pl-c1">5</span>)
<span class="pl-c">;=&gt; (5 10 15 20)</span></pre></div>

<p><code>cycle</code> returns an infinite lazy sequence of repetitions of the items in a collection:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take</span> <span class="pl-c1">6</span> (<span class="pl-en">cycle</span> (<span class="pl-en">range</span> <span class="pl-c1">5</span> <span class="pl-c1">50</span> <span class="pl-c1">5</span>)))
<span class="pl-c">;=&gt; (5 10 15 20 25 30)</span></pre></div>

<h2>
<a id="transforming-sequences" class="anchor" href="#transforming-sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transforming Sequences</h2>

<p><code>map</code> applies a function to each element, but it has a few more tricks up its sleeve:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">map</span> (<span class="pl-k">fn</span> [n vehicle] (<span class="pl-en">str</span> <span class="pl-s"><span class="pl-pds">"</span>I've got <span class="pl-pds">"</span></span> n <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> vehicle <span class="pl-s"><span class="pl-pds">"</span>s<span class="pl-pds">"</span></span>))
   [<span class="pl-c1">0</span> <span class="pl-c1">200</span> <span class="pl-c1">9</span>]
   [<span class="pl-s"><span class="pl-pds">"</span>car<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>train<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>kiteboard<span class="pl-pds">"</span></span>])
<span class="pl-c">;=&gt; ("I've got 0 cars" "I've got 200 trains" "I've got 9 kiteboards")</span></pre></div>

<p>If given multiple sequences, <code>map</code> calls its function with one element from each sequence in turn. So the first value will be <code>(f 0 "car")</code>, the second <code>(f 200 "train")</code>, and so on. Like a zipper, map folds together corresponding elements from multiple collections. To sum three vectors, column-wise:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">map</span> + [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>]
        [<span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>]
        [<span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>])
<span class="pl-c">;=&gt; (8 9 10)</span></pre></div>

<p>If one sequence is bigger than another, <code>map</code> stops at the end of the smaller one. We can exploit this to combine finite and infinite sequences. For example, to number the elements in a vector:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">map</span> (<span class="pl-k">fn</span> [index element] (<span class="pl-en">str</span> index <span class="pl-s"><span class="pl-pds">"</span>. <span class="pl-pds">"</span></span> element))
      (<span class="pl-en">iterate</span> inc <span class="pl-c1">0</span>)
      [<span class="pl-s"><span class="pl-pds">"</span>erlang<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>scala<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>haskell<span class="pl-pds">"</span></span>])
<span class="pl-c">;=&gt; ("0. erlang" "1. scala" "2. haskell")</span></pre></div>

<p>Transforming elements together with their indices is so common that Clojure has a special function for it: <code>map-indexed</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">map-indexed</span> (<span class="pl-k">fn</span> [index element] (<span class="pl-en">str</span> index <span class="pl-s"><span class="pl-pds">"</span>. <span class="pl-pds">"</span></span> element))
              [<span class="pl-s"><span class="pl-pds">"</span>erlang<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>scala<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>haskell<span class="pl-pds">"</span></span>])
<span class="pl-c">;=&gt; ("0. erlang" "1. scala" "2. haskell")</span></pre></div>

<p>You can also tack one sequence onto the end of another, like so:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">concat</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>] [<span class="pl-c1">:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span>] [<span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span>])
<span class="pl-c">;=&gt; (1 2 3 :a :b :c 4 5 6)</span></pre></div>

<p>Another way to combine two sequences is to riffle them together, using <code>interleave</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">interleave</span> [<span class="pl-c1">:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:c</span>] [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; (:a 1 :b 2 :c 3)</span></pre></div>

<p>And if you want to insert a specific element between each successive pair in a sequence, try <code>interpose</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">interpose</span> <span class="pl-c1">:and</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (1 :and 2 :and 3 :and 4)</span></pre></div>

<p>To reverse a sequence, use ... you guessed it, <code>reverse</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">reverse</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; (3 2 1)</span>

(<span class="pl-en">reverse</span> <span class="pl-s"><span class="pl-pds">"</span>woolf<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; (\f \l \o \o \w)  ;not a string</span></pre></div>

<p>Strings are sequences too! Each element of a string is a character, written <code>\f</code>. You can rejoin those characters into a string with <code>apply str</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">apply</span> str (<span class="pl-en">reverse</span> <span class="pl-s"><span class="pl-pds">"</span>woolf<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; "floow"</span></pre></div>

<p>…and break strings up into sequences of chars with <code>seq</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">seq</span> <span class="pl-s"><span class="pl-pds">"</span>sato<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; (\s \a \t \o)</span></pre></div>

<p>To randomize the order of a sequence, use <code>shuffle</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">shuffle</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span> <span class="pl-c1">5</span>])
<span class="pl-c">;=&gt; [4 3 5 1 2]</span>

(<span class="pl-en">apply</span> str (<span class="pl-en">shuffle</span> (<span class="pl-en">seq</span> <span class="pl-s"><span class="pl-pds">"</span>abracadabra<span class="pl-pds">"</span></span>)))
<span class="pl-c">;=&gt; "raradbabaac"</span></pre></div>

<h2>
<a id="subsequences" class="anchor" href="#subsequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Subsequences</h2>

<p><code>take</code> selects the first <code>n</code> elements
<code>drop</code> removes the first <code>n</code> elements
<code>take-last</code> and <code>drop-last</code> operate on the last <code>n</code> elements:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take</span> <span class="pl-c1">3</span> (<span class="pl-en">range</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; (0 1 2)</span>

(<span class="pl-en">drop</span> <span class="pl-c1">3</span> (<span class="pl-en">range</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; (3 4 5 6 7 8 9)</span>

(<span class="pl-en">take-last</span> <span class="pl-c1">3</span> (<span class="pl-en">range</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; (7 8 9)</span>

(<span class="pl-en">drop-last</span> <span class="pl-c1">3</span> (<span class="pl-en">range</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; (0 1 2 3 4 5 6)</span></pre></div>

<p><code>take-while</code> and <code>drop-while</code> work just like <code>take</code> and <code>drop</code>, but use a function to decide when to stop:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take-while</span> pos? [<span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">-1</span> <span class="pl-c1">-2</span> <span class="pl-c1">10</span>])
<span class="pl-c">;=&gt; (3 2 1)</span></pre></div>

<p>In general, one can cut a sequence in twain by using <code>split-at</code> with a particular index. There’s also <code>split-with</code>, which uses a function to decide when to cut:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">split-at</span> <span class="pl-c1">4</span> (<span class="pl-en">range</span> <span class="pl-c1">10</span>))
<span class="pl-c">;=&gt; [(0 1 2 3) (4 5 6 7 8 9)]</span>

(<span class="pl-en">split-with</span> number? [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">:mark</span> <span class="pl-c1">4</span> <span class="pl-c1">5</span> <span class="pl-c1">6</span> <span class="pl-c1">:mark</span> <span class="pl-c1">7</span>])
<span class="pl-c">;=&gt; [(1 2 3) (:mark 4 5 6 :mark 7)]</span></pre></div>

<p>Notice that because indexes start at zero, sequence functions tend to have predictable number of elements.<code>(split-at 4)</code> yields four elements in the first collection, and ensures the second collection begins at index four. <code>(range 10)</code> has ten elements, corresponding to the first ten indices in a sequence. <code>(range 3 5)</code> has two (as in <code>5 - 3 = 2</code>) elements. These choices simplify the definition of recursive functions as well.
We can select particular elements from a sequence by applying a function. To pull up all positive numbers in a list, use <code>filter</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">filter</span> pos? [<span class="pl-c1">1</span> <span class="pl-c1">5</span> <span class="pl-c1">-4</span> <span class="pl-c1">-7</span> <span class="pl-c1">3</span> <span class="pl-c1">0</span>])
<span class="pl-c">;=&gt; (1 5 3)</span></pre></div>

<p><code>filter</code> looks at each element in turn, and includes it in the resulting sequence only if <code>(f element)</code> returns a <em>truthy</em> value. Its complement is <code>remove</code>, which only includes those elements where <code>(f element)</code> is <code>false</code> or <code>nil</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">remove</span> string? [<span class="pl-c1">1</span> <span class="pl-s"><span class="pl-pds">"</span>tur<span class="pl-pds">"</span></span> <span class="pl-c1">:apple</span>])
<span class="pl-c">;=&gt; (1 :apple)</span></pre></div>

<p>One can group a sequence into chunks using <code>partition</code>, <code>partition-all</code>, or <code>partition-by</code>. For instance, one might group alternating values into pairs like this:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">partition</span> <span class="pl-c1">2</span> [<span class="pl-c1">:cats</span> <span class="pl-c1">5</span> <span class="pl-c1">:bats</span> <span class="pl-c1">27</span> <span class="pl-c1">:crocs</span> <span class="pl-c1">0</span>])
<span class="pl-c">;=&gt; ((:cats 5) (:bats 27) (:crocs 0))</span></pre></div>

<p>Separate a series of numbers into negative and positive subsequences:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">partition-by</span> neg? [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-c1">-1</span> <span class="pl-c1">-2</span> <span class="pl-c1">-3</span> <span class="pl-c1">-2</span> <span class="pl-c1">-1</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; ((1 2 3 2 1) (-1 -2 -3 -2 -1) (1 2))</span></pre></div>

<p><code>partition-all n collection</code> may include partitions with fewer than <code>n</code> items at the end:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">partition-all</span> <span class="pl-c1">3</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">-5</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-c1">-1</span> <span class="pl-c1">-2</span> <span class="pl-c1">-3</span> <span class="pl-c1">-2</span> <span class="pl-c1">-1</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; ((1 2 -5) (3 2 1) (-1 -2 -3) ( -2 -1 1) ( 2))</span></pre></div>

<p>while <code>partition</code> may not:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">partition</span> <span class="pl-c1">3</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">-5</span> <span class="pl-c1">3</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-c1">-1</span> <span class="pl-c1">-2</span> <span class="pl-c1">-3</span> <span class="pl-c1">-2</span> <span class="pl-c1">-1</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; ((1 2 -5) (3 2 1) (-1 -2 -3) (-2 -1 1))</span></pre></div>

<h3>
<a id="collapsing-subsequences" class="anchor" href="#collapsing-subsequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collapsing subsequences</h3>

<p>After transforming a sequence, we often want to collapse it in some way, in order to derive some smaller value. For instance, we might want the number of times each element appears in a sequence:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">frequencies</span> [<span class="pl-c1">:meow</span> <span class="pl-c1">:mrrrow</span> <span class="pl-c1">:meow</span> <span class="pl-c1">:meow</span>])
<span class="pl-c">;=&gt; {:meow 3, :mrrrow 1}</span></pre></div>

<p>To group elements by some function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">pprint</span> (<span class="pl-en">group-by</span> <span class="pl-c1">:first</span> [{<span class="pl-c1">:first</span> <span class="pl-s"><span class="pl-pds">"</span>Li<span class="pl-pds">"</span></span>    <span class="pl-c1">:last</span> <span class="pl-s"><span class="pl-pds">"</span>Zhou<span class="pl-pds">"</span></span>}
                           {<span class="pl-c1">:first</span> <span class="pl-s"><span class="pl-pds">"</span>Sarah<span class="pl-pds">"</span></span> <span class="pl-c1">:last</span> <span class="pl-s"><span class="pl-pds">"</span>Lee<span class="pl-pds">"</span></span>}
                           {<span class="pl-c1">:first</span> <span class="pl-s"><span class="pl-pds">"</span>Sarah<span class="pl-pds">"</span></span> <span class="pl-c1">:last</span> <span class="pl-s"><span class="pl-pds">"</span>Dunn<span class="pl-pds">"</span></span>}
                           {<span class="pl-c1">:first</span> <span class="pl-s"><span class="pl-pds">"</span>Li<span class="pl-pds">"</span></span>    <span class="pl-c1">:last</span> <span class="pl-s"><span class="pl-pds">"</span>O'Toole<span class="pl-pds">"</span></span>}]))
<span class="pl-c">;=&gt; {"Li" [{:last "Zhou", :first "Li"} {:last "O'Toole", :first "Li"}],</span>
<span class="pl-c">;=&gt;  "Sarah" [{:last "Lee", :first "Sarah"} {:last "Dunn", :first "Sarah"}]}</span></pre></div>

<p>Here we’ve taken a sequence of people with first and last names, and used the <code>:first</code> keyword (which can act as a function!) to look up those first names. <code>group-by</code> used that function to produce a map of first names to lists of people, kind of like an index.
In general, we want to combine elements together in some way, using a function. Where <code>map</code> treated each element independently, reducing a sequence requires that we bring some information along. The most general way to collapse a sequence is <code>reduce</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">doc</span> reduce)
<span class="pl-c">;=&gt; -------------------------</span>
<span class="pl-c">;=&gt; clojure.core/reduce</span>
<span class="pl-c">;=&gt; ([f coll] [f val coll])</span>
<span class="pl-c">;=&gt;   f should be a function of 2 arguments. If val is not supplied,</span>
<span class="pl-c">;=&gt;   returns the result of applying f to the first 2 items in coll, then</span>
<span class="pl-c">;=&gt;   applying f to that result and the 3rd item, etc. If coll contains no</span>
<span class="pl-c">;=&gt;   items, f must accept no arguments as well, and reduce returns the</span>
<span class="pl-c">;=&gt;   result of calling f with no arguments.  If coll has only 1 item, it</span>
<span class="pl-c">;=&gt;   is returned and f is not called.  If val is supplied, returns the</span>
<span class="pl-c">;=&gt;   result of applying f to val and the first item in coll, then</span>
<span class="pl-c">;=&gt;   applying f to that result and the 2nd item, etc. If coll contains no</span>
<span class="pl-c">;=&gt;   items, returns val and f is not called.</span>

(<span class="pl-en">reduce</span> + [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; 10</span>

(<span class="pl-en">reduce</span> + <span class="pl-c1">1</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; 11</span></pre></div>

<p>To see the reducing process in action, we can use <code>reductions</code>, which returns a sequence of all the intermediate states:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">reductions</span> + [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (1 3 6 10)</span></pre></div>

<p>Oftentimes we include a default state to start with. For instance, we could start with an empty set, and add each element to it as we go along:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">reduce</span> conj #{} [<span class="pl-c1">:a</span> <span class="pl-c1">:b</span> <span class="pl-c1">:b</span> <span class="pl-c1">:b</span> <span class="pl-c1">:a</span> <span class="pl-c1">:c</span>])
<span class="pl-c">;=&gt; #{:a :c :b}</span></pre></div>

<p>Reducing elements into a collection has its own name: <code>into</code>. We can <code>conj [key value]</code> vectors into a map, for instance, or build up a list:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">into</span> {} [[<span class="pl-c1">:a</span> <span class="pl-c1">2</span>] [<span class="pl-c1">:b</span> <span class="pl-c1">3</span>]])
<span class="pl-c">;=&gt; {:a 2, :b 3}</span>

(<span class="pl-en">into</span> (<span class="pl-en">list</span>) [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; (4 3 2 1)</span></pre></div>

<p>Because <strong>elements added to a list appear at the beginning</strong>, not the end, this expression <strong>reverses the sequence</strong>. Vectors <code>conj</code> onto the end, so to emit the elements in order, using reduce, we might try:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">reduce</span> conj [] [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span> <span class="pl-c1">5</span>])
<span class="pl-c">;=&gt; [1 2 3 4 5]</span></pre></div>

<p>Remember?</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">conj</span> [<span class="pl-c1">-1</span> <span class="pl-c1">0</span>] [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span> <span class="pl-c1">5</span>])
<span class="pl-c">;=&gt; [-1 0 [1 2 3 4 5]]               ; not [-1 0 1 2 3 4 5]</span></pre></div>

<p>This looks like a <code>map</code> function. All that’s missing is some kind of transformation applied to each element:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">my-map</span> [f coll]
   (<span class="pl-en">reduce</span> (<span class="pl-k">fn</span> [output element]
             (<span class="pl-en">conj</span> output (<span class="pl-en">f</span> element)))
           []
           coll))
<span class="pl-c">;=&gt; #'user/my-map</span>

(<span class="pl-en">my-map</span> inc [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>])
<span class="pl-c">;=&gt; [2 3 4 5]</span></pre></div>

<p>So <code>map</code> is just a special kind of <code>reduce</code>. What about, say, <code>take-while</code>?</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">my-take-while</span> [f coll]
   (<span class="pl-en">reduce</span> (<span class="pl-k">fn</span> [out elem]
             (<span class="pl-k">if</span> (<span class="pl-en">f</span> elem)
               (<span class="pl-en">conj</span> out elem)
               (<span class="pl-en">reduced</span> out)))
           []
           coll))
<span class="pl-c">;=&gt; #'user/my-take-while</span></pre></div>

<p>We’re using a special function here, <code>reduced</code>, to indicate that we’ve completed our reduction early and can skip the rest of the sequence.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">my-take-while</span> pos? [<span class="pl-c1">2</span> <span class="pl-c1">1</span> <span class="pl-c1">0</span> <span class="pl-c1">-1</span> <span class="pl-c1">0</span> <span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; [2 1]</span></pre></div>

<p>Most of Clojure’s <strong>sequence functions are lazy</strong>. For instance, we can increment every number from zero to infinity:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">infseq</span> (<span class="pl-en">map</span> inc (<span class="pl-en">iterate</span> inc <span class="pl-c1">0</span>)))
<span class="pl-c">;=&gt; #'user/infseq</span>

(<span class="pl-en">realized?</span> infseq)
<span class="pl-c">;=&gt; false</span></pre></div>

<p>That function returned immediately. Because it hasn’t done any work yet, we say the sequence is unrealized. It doesn’t increment any numbers at all until we ask for them:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">take</span> <span class="pl-c1">10</span> infseq)
<span class="pl-c">;=&gt; (1 2 3 4 5 6 7 8 9 10)</span>

(<span class="pl-en">realized?</span> infseq)
<span class="pl-c">;=&gt; true</span></pre></div>

<p><strong>Lazy sequences also remember their contents, once evaluated, for faster access.</strong></p>

<p>Find the sum of the products of consecutive pairs of the first 1000 odd integers.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">reduce</span> +
         (<span class="pl-en">take</span> <span class="pl-c1">1000</span>
               (<span class="pl-en">map</span> (<span class="pl-k">fn</span> [pair] (<span class="pl-en">*</span> (<span class="pl-en">first</span> pair) (<span class="pl-en">second</span> pair)))
                    (<span class="pl-en">partition</span> <span class="pl-c1">2</span> <span class="pl-c1">1</span>
                      (<span class="pl-en">filter</span> odd?
                        (<span class="pl-en">iterate</span> inc <span class="pl-c1">0</span>))))))
<span class="pl-c">;=&gt; 1335333000</span></pre></div>

<p><strong>Homework:</strong></p>

<ol>
<li>Write a function to find out if a string is a palindrome.</li>
</ol>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">palindrome?</span> [word] 
  (<span class="pl-en">==</span> <span class="pl-c1">0</span> (<span class="pl-en">compare</span> word (<span class="pl-en">apply</span> str (<span class="pl-en">reverse</span> word)))))</pre></div>

<ol>
<li>Find the number of <code>c</code>s in <code>“abracadabra”</code>.</li>
</ol>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">occurs-count</span> [c word]
  (<span class="pl-en">get</span> (<span class="pl-en">frequencies</span> (<span class="pl-en">seq</span> word)) c <span class="pl-c1">0</span>))</pre></div>

<ol>
<li>Write your own version of <code>filter</code>.</li>
</ol>

<div class="highlight highlight-clj"><pre><span class="pl-c">;=&gt; TBD</span></pre></div>

<h1>
<a id="java-interop" class="anchor" href="#java-interop" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java interop</h1>

<p>Clojure is <em>symbiotic</em> with its host, providing its rich and powerful features, while Java provides an object model, libraries and runtime support.</p>

<p>Clojure strings are Java <code>String</code>s, numbers are <code>Number</code>s, collections implement <code>Collection</code>, fns implement <code>Callable</code> and <code>Runnable</code>, ...</p>

<p>Core abstractions, such as <code>seq</code>, are Java interfaces (<code>ISeq</code>).<br>
Clojure <code>seq</code> library works on Java <code>Iterable</code>s, <code>String</code>s and arrays.<br>
It is possible to implement and extend Java interfaces and classes.  </p>

<p><strong>Accessing static class members</strong></p>

<p>... is trivial:</p>

<div class="highlight highlight-clj"><pre>java.util.Locale/JAPAN
<span class="pl-c">;=&gt; #&lt;Locale ja_JP&gt;</span></pre></div>

<p>Idiomatic Clojure prefers that you access static class members using a syntax like accessing a namespace-qualified Var:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">Math/sqrt</span> <span class="pl-c1">9</span>)  <span class="pl-c">; the same as (java.lang.Math/sqrt 9)</span>
<span class="pl-c">;=&gt; 3.0</span></pre></div>

<p><strong>Creating Java class instances</strong></p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">new</span> java.util.HashMap {<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-c1">42</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> <span class="pl-c1">8</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>beep boop<span class="pl-pds">"</span></span>})
<span class="pl-c">;=&gt; {"baz" "beep boop", "foo" 42, "bar" 8}</span>

<span class="pl-c">;;idiomatic:</span>
(<span class="pl-en">java.util.HashMap.</span> {<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-c1">42</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> <span class="pl-c1">8</span> <span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>beep boop<span class="pl-pds">"</span></span>})   <span class="pl-c">;dot = constructor call</span>
<span class="pl-c">;=&gt; {"baz" "beep boop", "foo" 42, "bar" 8}</span></pre></div>

<p><strong>Accessing Java instance members with the dot operator</strong></p>

<p>To access instance properties, precede the property or method name with a dot:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">.x</span> (<span class="pl-en">java.awt.Point.</span> <span class="pl-c1">10</span> <span class="pl-c1">20</span>))  <span class="pl-c">;create a new Point and access its member x</span>
<span class="pl-c">;=&gt; 10</span></pre></div>

<p>To access instance methods, the dot form allows an additional argument to be passed to the method:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">.divide</span> (<span class="pl-en">java.math.BigDecimal.</span> <span class="pl-s"><span class="pl-pds">"</span>42<span class="pl-pds">"</span></span>) <span class="pl-c1">2</span>K)
<span class="pl-c">;=&gt; 21M</span>

<span class="pl-c">; what's this M for?</span>
(<span class="pl-en">type</span> <span class="pl-c1">2</span>M)
<span class="pl-c">;=&gt; java.math.BigDecimal</span></pre></div>

<p><strong>Setting Java instance properties</strong></p>

<p>In the absence of mutator methods, in the form of <code>setX</code>, Java instance properties can be set using <code>set!</code> function:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [origin (<span class="pl-en">java.awt.Point.</span> <span class="pl-c1">0</span> <span class="pl-c1">0</span>)]
  (<span class="pl-en">set!</span> (<span class="pl-en">.x</span> origin) <span class="pl-c1">15</span>)     <span class="pl-c">;(set! &lt;instance_member_access&gt; &lt;value&gt;)</span>
  (<span class="pl-en">str</span> origin))
<span class="pl-c">;=&gt; "java.awt.Point[x=15,y=0]"</span></pre></div>

<p><strong>The <code>..</code> macro</strong></p>

<p>For now, think of a macro as a convenience function. We'll meet them <a href="#macros">later</a>.<br>
In Java, it's a common practice to chain together a sequence of method calls, e.g:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">new</span> <span class="pl-smi">java.util<span class="pl-k">.</span>Date</span>()<span class="pl-k">.</span>toString()<span class="pl-k">.</span>endsWith(<span class="pl-s"><span class="pl-pds">"</span>2014<span class="pl-pds">"</span></span>)  ;java</pre></div>

<p>... which is equivalent to this Clojure expression:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">.endsWith</span> (<span class="pl-en">.toString</span> (<span class="pl-en">java.util.Date.</span>)) <span class="pl-s"><span class="pl-pds">"</span>2014<span class="pl-pds">"</span></span>)
<span class="pl-c">;=&gt; true</span></pre></div>

<p>Well, anyone would agree that this is rather difficult to read.<br>
To remedy this, Clojure provides us with <code>..</code> macro:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">..</span> (<span class="pl-en">java.util.Date.</span>) toString (<span class="pl-en">endsWith</span> <span class="pl-s"><span class="pl-pds">"</span>2014<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; true</span></pre></div>

<p><strong>The <code>doto</code> macro</strong></p>

<p>In Java, it's also common to initialize a fresh instance by calling a set of mutators:</p>

<div class="highlight highlight-java"><pre><span class="pl-smi">java.util<span class="pl-k">.</span>HashMap</span> props <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">java.util<span class="pl-k">.</span>HashMap</span>();  <span class="pl-c">/* java */</span>
props<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">"</span>HOME<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>/home/myself<span class="pl-pds">"</span></span>);
props<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">"</span>SRC<span class="pl-pds">"</span></span>,  <span class="pl-s"><span class="pl-pds">"</span>src<span class="pl-pds">"</span></span>);
props<span class="pl-k">.</span>put(<span class="pl-s"><span class="pl-pds">"</span>BIN<span class="pl-pds">"</span></span>,  <span class="pl-s"><span class="pl-pds">"</span>classes<span class="pl-pds">"</span></span>);</pre></div>

<p>That's obviously overly verbose, but it can be streamlined using the <code>doto</code> macro:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">doto</span> (<span class="pl-en">java.util.HashMap.</span>)       <span class="pl-c">;do to HashMap all these things</span>
  (<span class="pl-en">.put</span> <span class="pl-s"><span class="pl-pds">"</span>HOME<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>/home/myself<span class="pl-pds">"</span></span>)
  (<span class="pl-en">.put</span> <span class="pl-s"><span class="pl-pds">"</span>SRC<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>src<span class="pl-pds">"</span></span>)
  (<span class="pl-en">.put</span> <span class="pl-s"><span class="pl-pds">"</span>BIN<span class="pl-pds">"</span></span>  <span class="pl-s"><span class="pl-pds">"</span>classes<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; {"HOME" "/home/myself", "BIN" "classes", "SRC" "src"}</span></pre></div>

<h1>
<a id="exceptions" class="anchor" href="#exceptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exceptions</h1>

<p>Like Java, Clojure also provides <code>try</code>, <code>catch</code>, <code>finally</code> and <code>throw</code> forms:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">throw</span> (<span class="pl-en">Exception.</span> <span class="pl-s"><span class="pl-pds">"</span>Thrown<span class="pl-pds">"</span></span>))

<span class="pl-c">;=&gt; Exception Thrown  user/eval1201 (form-init8547084957850583270.clj:1)</span>

(<span class="pl-k">defn</span> <span class="pl-e">throw-catch</span> [f]
  [(<span class="pl-k">try</span>
    (<span class="pl-en">f</span>)
    (<span class="pl-k">catch</span> ArithmeticException e <span class="pl-s"><span class="pl-pds">"</span>You did not? Not by zero! Noooooooooooo...<span class="pl-pds">"</span></span>)
    (<span class="pl-k">catch</span> Exception e (<span class="pl-en">str</span> <span class="pl-s"><span class="pl-pds">"</span>You blew it <span class="pl-pds">"</span></span> (<span class="pl-en">.getMessage</span> e)))
    (<span class="pl-k">finally</span> (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>returning... <span class="pl-pds">"</span></span>)))])
<span class="pl-c">;=&gt; #'user/throw-catch</span>

(<span class="pl-k">throw-catch</span> #(<span class="pl-en">/</span> <span class="pl-c1">10</span> <span class="pl-c1">5</span>))
<span class="pl-c">;=&gt; returning... </span>
<span class="pl-c">;=&gt; [2]</span>

(<span class="pl-k">throw-catch</span> #(<span class="pl-en">/</span> <span class="pl-c1">10</span> <span class="pl-c1">0</span>))
<span class="pl-c">;=&gt; returning... </span>
<span class="pl-c">;=&gt; ["You did not? Not by zero! Noooooooooooo..."]</span>

(<span class="pl-k">throw-catch</span> #(<span class="pl-k">throw</span> (<span class="pl-en">Exception.</span> <span class="pl-s"><span class="pl-pds">"</span>dawg!<span class="pl-pds">"</span></span>)))
<span class="pl-c">;=&gt; returning... </span>
<span class="pl-c">;=&gt; ["You blew it dawg!"]</span></pre></div>

<blockquote>
<p>Clojure doesn't adhere to checked exception requirements, like Java does.</p>

<p>When an exception is thrown in REPL, the result is stored in a Var named <code>*e</code>, which allows you to get more detail about the expression, such as the stack trace:</p>
</blockquote>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">.printStackTrace</span> *e)</pre></div>

<h1>
<a id="namespaces" class="anchor" href="#namespaces" aria-hidden="true"><span class="octicon octicon-link"></span></a>Namespaces</h1>

<p>Provide a way to bundle related functions, macros and values.</p>

<p><strong>Creating namespaces using <code>ns</code> macro</strong></p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">ns</span> <span class="pl-e">mbo.core.strings</span>)
<span class="pl-c">;=&gt; nil</span>
<span class="pl-c">;=&gt; mbo.core.strings=&gt;    ;from now on, this is our REPL prompt</span></pre></div>

<p>There's also a <em>Var</em> <code>*ns*</code>, which holds the value of the current namespace.<br>
We know from before that any <em>Var</em> created will be a member of the current namespace.</p>

<div class="highlight highlight-clj"><pre>mbo.core.strings=&gt; (<span class="pl-k">defn</span> <span class="pl-e">report-ns</span> [] (<span class="pl-en">str</span> <span class="pl-s"><span class="pl-pds">"</span>The current namespace is <span class="pl-pds">"</span></span> *ns*))
<span class="pl-c">;=&gt; #'mbo.core.strings/report-ns</span>

mbo.core.strings=&gt; (<span class="pl-en">report-ns</span>)
<span class="pl-c">;=&gt; "The current namespace is mbo.core.strings"</span>

mbo.core.strings=&gt; (<span class="pl-k">defn</span> <span class="pl-e">sing</span> [] (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>Marjane Marjane, Marjane Marjane, ...<span class="pl-pds">"</span></span>))
<span class="pl-c">;=&gt; #'mbo.core.strings/sing</span>

mbo.core.strings=&gt; sing    <span class="pl-c">;Clojure looks it up in the current namespace</span>
<span class="pl-c">;=&gt; #&lt;strings$sing mbo.core.strings$sing@3987b05&gt;</span>

mbo.core.strings=&gt; (<span class="pl-k">ns</span> <span class="pl-e">mbo.core.compat</span>)   <span class="pl-c">;create another namespace</span>
<span class="pl-c">;=&gt; nil</span>

mbo.core.compat=&gt; (<span class="pl-en">report-ns</span>)             <span class="pl-c">;try invoking function from another ns</span>

mbo.core.compat=&gt; CompilerException java.lang.RuntimeException: 
<span class="pl-c">;=&gt; Unable to resolve symbol: report-ns in this context, </span>
<span class="pl-c">;=&gt; compiling:(/tmp/form-init8547084957850583270.clj:1:1)</span>

mbo.core.compat=&gt; (<span class="pl-en">mbo.core.strings/report-ns</span>) <span class="pl-c">;fully qualified name works as expected</span>
<span class="pl-c">;=&gt; "The current namespace is mbo.core.compat"</span></pre></div>

<blockquote>
<p>referring to a namespace symbol using fully qualified name will only work for namespaces created locally or those previously loaded. Read on, it'll become clear...</p>
</blockquote>

<p><strong>Using <code>:require</code> directive to load other namespaces</strong></p>

<div class="highlight highlight-clj"><pre>mbo.core.compat=&gt; (<span class="pl-k">ns</span> <span class="pl-e">mbo.core.set</span>
                    (<span class="pl-c1">:require</span> clojure.set))
<span class="pl-c">;=&gt; nil</span>
<span class="pl-c">;=&gt; mbo.core.set=&gt;  ;changed to new ns</span>

mbo.core.set=&gt; (<span class="pl-en">clojure.set/intersection</span> #{<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>} #{<span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>})
<span class="pl-c">;=&gt; #{2 3}</span>

mbo.core.set=&gt; (<span class="pl-en">intersection</span> #{<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>} #{<span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>})  <span class="pl-c">;invoke a clojure.set function directly</span>

<span class="pl-c">;=&gt; CompilerException java.lang.RuntimeException: Unable to resolve symbol: </span>
<span class="pl-c">;=&gt; intersection in this context, compiling:(/tmp/form-init8547084957850583270.clj:1:1)</span></pre></div>

<p>This construct indicates that we want the <code>clojure.set</code> namespace loaded, but we don't want the mappings of that namespace's symbols to <code>mbo.core.set</code> functions.</p>

<p>We can also use <code>:as</code> directive to create an additional alias to <code>clojure.set</code>:</p>

<div class="highlight highlight-clj"><pre>mbo.core.set=&gt; (<span class="pl-k">ns</span> <span class="pl-e">mbo.core.set-alias</span>
                    #<span class="pl-e">_=&gt;</span>   (<span class="pl-c1">:require</span> [clojure.set <span class="pl-c1">:as</span> s]))
<span class="pl-c">;=&gt; nil</span>

mbo.core.set-alias=&gt; (<span class="pl-en">s/intersection</span> #{<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>} #{<span class="pl-c1">2</span> <span class="pl-c1">3</span> <span class="pl-c1">4</span>})
<span class="pl-c">;=&gt; #{2 3}</span></pre></div>

<p>The qualified namespace form (e.g. <code>clojure.set</code>) looks the same as a call to a <em>static class method</em>. The difference is that a <em>namespace symbol</em> can only be used as a qualifier, whereas a <em>class symbol</em> can also be referenced independently:</p>

<div class="highlight highlight-clj"><pre>mbo.core.set-alias=&gt; clojure.set

<span class="pl-c">;=&gt; mbo.core.set-alias=&gt; CompilerException java.lang.ClassNotFoundException: </span>
<span class="pl-c">;=&gt; clojure.set, compiling:(/tmp/form-init8547084957850583270.clj:1:691) </span>

mbo.core.set-alias=&gt; java.lang.Object
<span class="pl-c">;=&gt; java.lang.Object</span></pre></div>

<blockquote>
<p>That vagaries of namespace mappings from symbols to <em>Vars</em>, both qualified and unqualified, have the potential for confusion between <em>class names</em> and <em>static methods</em>. In the beginning, that is. The differences will begin to feel natural as we progress (at least that's what <em>The joy of Clojure</em> book promises :)
One of the Clojure idioms is to use <code>my.Class</code> and <code>my.ns</code> for naming classes and namespaces, to help eliminate potential confusion.</p>
</blockquote>

<p><strong>Loading and creating mappings with <code>:use</code></strong></p>

<p><code>:use</code>, unlike <code>:require</code>, maps Vars in another namespace to names in your own. That is typically used to avoid calling each function or macro with the qualifying namespace symbol:</p>

<div class="highlight highlight-clj"><pre>mbo.core.set-alias=&gt; (<span class="pl-k">ns</span> <span class="pl-e">mbo.test</span>
                #<span class="pl-e">_=&gt;</span>   (<span class="pl-c1">:use</span> [clojure.string <span class="pl-c1">:only</span> [capitalize]]))
<span class="pl-c">;=&gt; nil</span>

mbo.test=&gt; (<span class="pl-en">map</span> capitalize [<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>])
<span class="pl-c">;=&gt; ("One" "Two")</span>
<span class="pl-c">;=&gt; mbo.test=&gt;</span></pre></div>

<p><code>:only</code> is used to indicate that only the listed functions should be mapped in the new namespace (good practice). The <code>:exclude</code> directive does the opposite.<br>
<code>:use</code>, besides creating mappings, implicitly invokes <code>:require</code>.</p>

<blockquote>
<p>the idiomatic strategy for avoiding conflicts is to use <code>:require</code> with <code>:as</code> to create a namespace alias</p>
</blockquote>

<p><strong>Create mappings with <code>:refer</code></strong></p>

<p><code>:refer</code> is a directive that works almost exactly like <code>:use</code>, except that it only creates mappings for libraries that have already been loaded (by being previously defined, by being one of Clojure's core namespaces or by having been explicitly loaded using <code>:require</code>).</p>

<p><strong>Loading Java classes with <code>:import</code></strong></p>

<div class="highlight highlight-clj"><pre>mbo.test=&gt; (<span class="pl-k">ns</span> <span class="pl-e">mbo.java</span>
      #<span class="pl-e">_=&gt;</span>   (<span class="pl-c1">:import</span> [java.util HashMap]
      #_=&gt;            [java.util.concurrent.atomic.AtomicLong]))
<span class="pl-c">;=&gt; nil</span>

mbo.java=&gt; (<span class="pl-en">HashMap.</span> {<span class="pl-s"><span class="pl-pds">"</span>happy?<span class="pl-pds">"</span></span> <span class="pl-c1">true</span>})
<span class="pl-c">;=&gt; {"happy?" true}</span></pre></div>

<blockquote>
<p>Any classes in the <code>java.lang</code> package are implicitly imported when namespaces are created</p>
</blockquote>

<p><strong><code>nil</code> punning</strong></p>

<p>Since, in Clojure, everything except <code>nil</code> and <code>false</code> is <code>true</code>, empty collections evaluate to <code>true</code> in boolean context. We need a way to test whether a collection is empty or not.  </p>

<p>This is where <em>nil punning</em> comes in:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-en">seq</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span> <span class="pl-c1">3</span>])
<span class="pl-c">;=&gt; (1 2 3)</span>

(<span class="pl-en">seq</span> [])
<span class="pl-c">;=&gt; nil</span></pre></div>

<p><code>seq</code> function returns a sequence view of a collection or <code>nil</code> if the collection is empty.</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">defn</span> <span class="pl-e">print-seq</span> [s]
  (<span class="pl-k">when</span> (<span class="pl-en">seq</span> s)
    (<span class="pl-en">prn</span> (<span class="pl-en">first</span> s))     <span class="pl-c">;prn prints each object in a newline (to the output stream)</span>
    (<span class="pl-k">recur</span> (<span class="pl-en">rest</span> s))))

(<span class="pl-en">print-seq</span> [<span class="pl-c1">1</span> <span class="pl-c1">2</span>])
<span class="pl-c">;=&gt; 1</span>
<span class="pl-c">;=&gt; 2</span>
<span class="pl-c">;=&gt; nil</span></pre></div>

<p>The use of <code>seq</code> as a terminating condition is the idiomatic way of testing whether a sequence is empty</p>

<h1>
<a id="destructuring" class="anchor" href="#destructuring" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destructuring</h1>

<p>Allows you to place a collection of names in a binding form where normally you'd put just a single name.  </p>

<blockquote>
<p>Destructuring is loosely related to <em>pattern matching</em> (found in Haskell or <a href="https://github.com/mbonaci/scala#case-classes-and-pattern-matching">Scala</a>), but much more limited in scope. For full-featured pattern matching in Clojure use <a href="http://github.com/dcolthorp/matchure">matchure</a>.</p>
</blockquote>

<p>Perhaps the simplest form of destructuring is picking apart a sequential thing (e.g. a vector or a list), giving each item a name:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [[fname mname lname] [<span class="pl-s"><span class="pl-pds">"</span>Frane<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>Luka<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>Bonaci<span class="pl-pds">"</span></span>]]
  (<span class="pl-en">str</span> lname <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> fname <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> mname))
<span class="pl-c">;=&gt; "Bonaci, Frane Luka"</span>

<span class="pl-c">;; although this is syntactically correct, it isn't factually accurate</span>
<span class="pl-c">;; my month and a half old twins are named Frane and Luka :)</span>
<span class="pl-c">;; what can I say, my wife is a hero (that's what everybody's telling me these days)</span>
<span class="pl-c">;; hmmm, I wonder why?</span></pre></div>

<p>This was a so called <em>positional destructuring</em>, which, as you might expect, doesn't work on maps and sets, because they are not logically aligned sequentially. But it does work on <code>java.util.regex.Matcher</code> and anything implementing <code>CharSequence</code> and <code>java.util.RandomAccess</code> interfaces.  </p>

<p><strong>Destructuring with a vector</strong></p>

<p>We can also use an ampersand in a destructuring vector to indicate that any remaining values of the input should be collected into a (possibly lazy) <code>seq</code>:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [[a b c &amp; more] (<span class="pl-en">range</span> <span class="pl-c1">10</span>)]
  (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>a b c are: <span class="pl-pds">"</span></span> a b c)
  (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>the rest is: <span class="pl-pds">"</span></span> more))
<span class="pl-c">;=&gt; a b c are:  0 1 2</span>
<span class="pl-c">;=&gt; the rest is:  (3 4 5 6 7 8 9)</span></pre></div>

<p>A useful feature of vector destructuring is <code>:as</code>, which is used to bind a local to the entire collection. It must be placed at the end, even after the <code>&amp;</code> local (if it exists):</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [range-vec (<span class="pl-en">vec</span> (<span class="pl-en">range</span> <span class="pl-c1">10</span>))
  [a b c &amp; more <span class="pl-c1">:as</span> all] range-vec]
  (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>a b c are: <span class="pl-pds">"</span></span> a b c)
  (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>the rest is <span class="pl-pds">"</span></span> more)
  (<span class="pl-en">println</span> <span class="pl-s"><span class="pl-pds">"</span>all is: <span class="pl-pds">"</span></span> all))
<span class="pl-c">;=&gt; a b c are:  0 1 2</span>
<span class="pl-c">;=&gt; the rest is  (3 4 5 6 7 8 9)</span>
<span class="pl-c">;=&gt; all is:  [0 1 2 3 4 5 6 7 8 9]</span></pre></div>

<blockquote>
<p>Notice the difference between <code>&amp;</code> and <code>:as</code>. While <code>:all</code> produces a vector, <code>&amp;</code> results with a <code>seq</code>.</p>
</blockquote>

<p><strong>Destructuring with a map</strong></p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">def</span> <span class="pl-e">full-name-map</span>
  {<span class="pl-c1">:fname</span> <span class="pl-s"><span class="pl-pds">"</span>Frane<span class="pl-pds">"</span></span> <span class="pl-c1">:mname</span> <span class="pl-s"><span class="pl-pds">"</span>Luka<span class="pl-pds">"</span></span> <span class="pl-c1">:lname</span> <span class="pl-s"><span class="pl-pds">"</span>Bonaci<span class="pl-pds">"</span></span>})

(<span class="pl-k">let</span> [{fname :fname, mname :mname, lname <span class="pl-c1">:lname</span>} full-name-map]
  (<span class="pl-en">str</span> lname <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> fname <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> mname))
<span class="pl-c">;=&gt; "Bonaci, Frane Luka"</span></pre></div>

<p>Here, the <code>:keys</code> feature might come in handy:</p>

<div class="highlight highlight-clj"><pre>(<span class="pl-k">let</span> [{<span class="pl-c1">:keys</span> [fname mname lname]} full-name-map]
  (<span class="pl-en">str</span> lname <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span> fname <span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span> mname))
<span class="pl-c">;=&gt; "Bonaci, Frane Luka"</span></pre></div>

<p>By using <code>:keys</code>, we're telling Clojure that the next form will be a vector of names that it should convert to keywords (e.g. <code>:fname</code>), in order to look </p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/mbonaci/clojure/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/mbonaci/clojure/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/mbonaci/clojure"></a> is maintained by <a href="https://github.com/mbonaci">mbonaci</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-48000266-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
