{"name":"Clojure","tagline":"(Now former) Java developer sneaks up on Clojure","body":"*Written in January 2014, with Clojure 1.5.1 and Leiningen 2.3.4 on Java 1.7.0_45.*  \r\n_Inspired by Aphyr's excellent, Clojure from-the-ground-up tutorial and made possible by \"The joy of Clojure\" book. I also heavily used great \"Clojure for Java programmers\" talks by Rich Hickey, father of Clojure._  \r\n\r\n_Inspired? Made possible? Who am I kidding, I flat out stole from those kind people._\r\n\r\n\r\n## Clojure? That's a Lisp, for god's sake!\r\n\r\nI've been avoiding Clojure for a _long time_. Because it's a _Lisp dialect_ and I have a negative Lisp experience from school. It was either a bad timing or a bad teacher, I guess.  \r\nHmm, I guess my guessing about it, in itself, implies the answer :) \r\n\r\n> Times and times again it gets apparent to me. Late puberty nor adolescence is the right time to go wide with programming languages!\r\n\r\n# :)\r\n### It must had something to do with the way the book was written\r\n\r\nMy renewed interest in Clojure was due to a chance encounter. I stumbled upon Aphyr's (Kyle Kingsbury) fascinating [Jepsen series](http://aphyr.com/tags/jepsen), a blog about perils of uncertainty in distributed systems.  \r\n\r\nThere, Clojure looked terse and concise, yet expressive and simple. So I decided to give it a shot. I picked up [The joy of Clojure](http://joyofclojure.com), got in my sweatshirt, put on a headband, closed my wife and our two-month-old twins in the living room, slightly licked my finger and opened up the first page...\r\n\r\n> After the initial discovery phase, as I was going through the book, I suddenly found myself infatuated with the language. It's beautifully uniform, consistent and simple (which is different from \"easy\", mind you). At that point, it has just spread out to me, ready to be gulped away. And that's a great feeling!\r\n\r\n### How would you describe Clojure?\r\n\r\nClojure prides itself in being a **dynamic functional programming language**.  \r\nIt is built on three great facilities, **immutable data, first-class functions and dynamic typing**.  \r\n\r\n**Immutable data** means that a function always produces the same output, given the same input and that functions are side-effects free (when a function is run, nothing changes outside that function). All collections are immutable by design. Immutability in Clojure is not optional, like for instance, in Scala.\r\n\r\n**First class functions** means that a variable can be bound to a function, that a function can be passed to another (higher-order) function or that it may be returned from a function. In short, function is data.\r\n\r\n**Dynamic typing** means that we don't declare types. Data types are inferred by the compiler.\r\n\r\n> So from now on, when we say \"modify\", \"add\", \"remove\", ... it really means \"create a copy, modify the copy and return a reference to that new object\"  \r\n\r\n> In order to preserve the performance guarantees, while facilitating immutability Clojure uses something called **Structural sharing**, which basically means that the data structure of the newly created object simply points to the same elements the old object does, except the modified ones (that's called **path copying**).\r\n\r\n# Set the fuck up!\r\n### And gimme PRs\r\n\r\n<img src=\"https://github.com/mbonaci/clojure/raw/master/resources/lein.jpg\"\r\n alt=\"Leiningen logo\" title=\"The man himself\" align=\"right\" />\r\n\r\n> Disclaimer: I write this as I'm going through the book myself, so bear with me. Open pull requests as you see fit\r\n\r\nOK, that's more than enough BS (for now). Let's start by setting up our Clojure runtime environment.\r\n\r\nTo set it up, I suggest you use an excellent automation tool (dependency mgr, builder, test runner, packager, all-in-one) [Leiningen](http://leiningen.org/). \r\n\r\n> Notice there's no \"installer\" in the list of features. That's because Clojure is just another _dependency_ of \"our project\".\r\n\r\nFor your convenience, here's a dead simple, step-by-step environment setup for Ubuntu ([other OS, sir?](http://leiningen.org/#install)):\r\n<br>\r\n<br>\r\n<br>\r\n\r\n```sh\r\ncd /usr/bin\r\nsudo curl -O https://raw.github.com/technomancy/leiningen/stable/bin/lein\r\nsudo chmod a+x lein\r\n ```\r\n\r\nLet me explain what we just did. \r\nFirst we fetched `lein` script with `curl`° into `/usr/bin`°°.\r\nWe made sure it's executable with `chmod`.\r\n\r\n°  Use `sudo apt-get install curl`, if you haven't installed it yet (doesn't come OOTB with Ubuntu).  \r\n°° You can use any other dir, as long as you make sure it's in your PATH (check with `echo $PATH`), which makes possible to run it from anywhere.\r\n\r\nLet's kick things off:\r\n\r\n```sh\r\ncd\r\nlein new scratch\r\n ```\r\n\r\nHere we used `lein new` to create a fresh Clojure project, based on the `scratch` template (_scratch_ - as in _scratch the surface_, I guess).\r\nLein, in turn, installed _rest of itself_ into `~/.lein/self-installs`.\r\n\r\nIn case you get stuck, visit [lein install instructions](http://leiningen.org/#install).  \r\nIf you want to know more, the official Leiningen tutorial can be found [right here](https://github.com/technomancy/leiningen/blob/master/doc/TUTORIAL.md).\r\n\r\nLovely! Now fire along:\r\n\r\n```sh\r\ncd scratch\r\nlein repl\r\n```\r\n\r\nBoom! We have our own working Clojure environment.\r\n\r\n![repl](https://github.com/mbonaci/clojure/raw/master/resources/repl.png)\r\n\r\nREPL is short for _Read Eval Print Loop_, which is like an interactive window into a Clojure program (similar to a JavaScript console in the browser or REPL in Node).\r\n\r\nNow when that's all sorted and you're eager to learn, let's see how Clojure code looks like...\r\n\r\n# Basics\r\n\r\nA valid Clojure expression consists of _numbers_, _symbols_, _lists_, _keywords_, _booleans_, _characters_, _functions_, _function calls_, _macros_ (wtf?), _strings_, _literal maps_, _vectors_, and _sets_. \r\n\r\nAll of those, except _symbols_ and _lists_, evaluate to themselves.  \r\n\r\nSymbols are similar to variables in other languages, which basically means that, when a symbol is encountered, compiler tries to find the value that the symbol was previously (hopefully) bound to, which is then used in place of the symbol.  \r\n\r\nLists take a special place in Clojure (after all, Lisp means **LIS**t **P**rocessing). They are the main building block of the language.\r\nLists start with a so called _operation form_:\r\n\r\n```clj\r\n(op ...)\r\n```\r\n\r\n`op` can be either:\r\n - one of very few _special operations_ (listed bellow)\r\n - a _macro_\r\n - an expression that yields a _function_\r\n\r\nFor instance, if the Clojure compiler encounters:\r\n\r\n```clj\r\n(my-fun some-expr)\r\n```\r\n\r\nit'll first try to resolve `my-fun`, which in our case, is a previously defined function that conceptually looks like this:\r\n\r\n```clj\r\n(def my-fun value-expr)\r\n```\r\n\r\nThen, it'll evaluate `some-expr` and invoke the `my-fun` function, passing in the result.\r\n\r\n> so `my-fun` is a _symbol_ that is bound to a function definition\r\n\r\nFull list of **special operations**:\r\n\r\n```clojure\r\ndef     ;evaluates an expression and binds the result to a symbol\r\nif      ;conditional evaluation\r\nfn      ;defines a function\r\nlet     ;establishes a name in a local lexical scope\r\nloop    ;used for functional looping\r\nrecur   ;used to support recursion in functional looping\r\ndo      ;defines a block of statements\r\nnew     ;allocates a new java object\r\n.       ;used to access a java method\r\nthrow   ;same as in java\r\ntry     ;same as in java\r\nset!    ;re-binds a symbol\r\nquote   ;supresses evaluation of an expression (same as single quote, ')\r\nvar     ;provides a mechanism to refer to a mutable storage location inside a thread (?)\r\n```\r\n\r\nThe list above may contain some descriptions that may not be clear to you, but soon, if you stuck with it, it'll all get cleared. And that's a promise.\r\n\r\nHere's how a function invocation looks like:\r\n\r\n```clj\r\nuser=> (inc 2)      ;\"increment 2\"\r\n3                   ;this is REPL output\r\n;=> 3               ;which I'll write like this from now on\r\n\r\n; those three that begin with a semicolon are comments\r\n;;this one also, from that first semicolon to the end of the line. All the way here ->\r\n```\r\n\r\n## Syntax\r\n\r\n### Prefix/Polish notation\r\n\r\n```clj\r\n;; intentionally skipping java semicolons\r\n\r\n;;------------------------------------\r\n;;     Java             Clojure\r\n;;------------------------------------\r\nint i = 5              (def i 5)\r\n;;------------------------------------\r\nif(x == 0)             (if (zero? x)\r\n  return y               y\r\nelse                     z)\r\n  return z \r\n;;------------------------------------\r\nx * y * z              (* x y z)\r\n;;------------------------------------\r\nfoo(x, y, z)           (foo x y z)\r\n;;------------------------------------\r\n```\r\n\r\nYou can try the following example in your REPL:\r\n\r\n```clj\r\n;skipping the 'user=>' prompt from now on\r\n(+ 1 (- 5 2) (+ 3 4))\r\n;=> 11\r\n```\r\n\r\n> Uh, that looks somewhat weird, right?\r\n\r\nThis type of notation, inherited from Lisp, called a _prefix notation_ or _Polish notation_, may look weird at the first glance.  \r\n\r\nLet's back up a bit.  \r\nAll programming languages, in order to execute the source code, need to parse it first. \r\nIn most languages, the product of this code parsing is a so called _abstract syntax tree_ (_AST_), which is then fed into the compiler.  \r\n\r\nLet's see how that tree looks for the example at hand.  \r\nIn Java, the expression above would be written like this:\r\n\r\n```java\r\n1 + (5 - 2) + (3 + 4);   // parentheses left for clarity\r\n// 1 + 3 + 7\r\n// 11\r\n```\r\n\r\n... and the _AST_ would look like this:\r\n\r\n![ast](https://github.com/mbonaci/clojure/raw/master/resources/ast.png)\r\n\r\nAfter seeing what _AST_ (as the ideal structure for representing code) looks like, I argue that _prefix_ is the natural way of representing expressions.  \r\n\r\nWhen you think of it (really hard), as early as first grade maths, the only option we ever see is _infix_ notation, so that's what gets hardwired inside our brains.\r\n\r\nThat is why, IMO, the _Polish notation_ looks weird to us.\r\n\r\n> prefix notation allows any number of arguments in an operation (infix only two). Moreover, it completely eliminates the problem of operator precedence  \r\n\r\n> at this point I have to stress that this is my opinion after only a couple of weeks learning Clojure. I'm slightly affraid of what would happen to me after I explore all corners of the language :)\r\n\r\n### Clojure is different\r\n\r\nThis is how a program is executed in a traditional, java-style _edit-compile-run_ way:\r\n\r\n![ast](https://github.com/mbonaci/clojure/raw/master/resources/TraditionalEvaluation.png)\r\n\r\nIn Java (and it's similar in other traditional languages), the source code gets handed to the compiler, which compiles it to bytecode. The bytecode is then run on the JVM. If you need to change something in your code, e.g. fix a bug, you need to do the whole process all over again. Open up the source file, make some changes, compile the source code, then stop the whole program and finally send the new version of bytecode to the JVM to be executed.\r\n\r\nUh, we got over that hurdle. Now we confidently start our program but we soon notice that it's still not right. OK, we stop the whole program once more and then start it in a debug mode, carefully setting breakpoints along the way. But sometimes it's not that easy, or even possible to replicate the exact context where our bug has previously occurred.\r\n\r\n> at work, we often used to spend a better half of our day in this iterative process, doing nothing. When you combine that with IBM's tooling, that becomes a nightmare. E.g. Rational IDE weighs more than a GB. Websphere application server takes ages to start. When a new developer needs to set up his environment, it has known to take a couple of days to wire all the stuff together. We are crazy! How on earth we got eased into this unproductive way of working.\r\n\r\n![ast](https://github.com/mbonaci/clojure/raw/master/resources/ClojureEvaluation.png)\r\n\r\nClojure's evaluation is much more dynamic, the code first goes to **Reader**, which takes the characters and turns them into Clojure data structures.\r\nThe Compiler never sees the source code, it compiles the data structures produced by the Reader to bytecode, which is then run on the JVM.\r\n\r\nSo what does this mean? Can such a seemingly subtle difference have a noticeable impact on our development process?  \r\n\r\nThe point is that, this way, we can hot-swap a part of the running code without stopping the program. \r\nThe source code doesn't have to come from a file. We can use REPL to connect to a running program and evaluate expressions on the fly.\r\n\r\nThe other benefit is that other programs can easily produce data structures, thus avoiding source code and Reader all together. That's the Clojure's secret sauce. It's what makes **macros** possible.  \r\nWhen _Evaluator_, while processing source code, encounters a _macro_ (i.e. a symbol that is bound to a _macro_), it stops executing that part of the program and sends it to that _macro_, a _little side-program_ that manipulates data structures, transforming them in some useful way and then returning that, extended data structures back to the Evaluator.\r\n\r\nThis is extremely powerful concept, which allows us to extend the language without waiting for Rich Hickey to do so. Overwhelming amount of things, that are built-into other languages, are just macros in Clojure. For instance:\r\n\r\n```clj\r\n(or x y)        ;'or' is a macro in Clojure \r\n\r\n;;after being extended by or macro, becomes:\r\n\r\n(let [or__158 x]\r\n  (if or__158 or__158 y))\r\n```\r\n\r\nDon't worry if _macros_ are not clear yet (I explained them rather poorly, I know), we'll dedicate the whole chapter to that powerful construct.\r\n\r\n# Basics (this time real)\r\n\r\n## Scalar data types\r\n\r\nA scalar data type is the one that can only hold one value at a time (value of a number, symbol, keyword, string or a character).\r\n\r\n### Numeric types\r\n\r\nThe following examples of numeric expressions are trivial, so I suggest you try them out, in your REPL.\r\n\r\n```clj\r\n(type 3)\r\n;=> java.lang.Long\r\n\r\nLong/MAX_VALUE\r\n;=> 9223372036854775807\r\n\r\n(inc (bigint Long/MAX_VALUE))\r\n;=> 9223372036854775808N\r\n\r\n(type 5N)\r\n;=> clojure.lang.BigInt\r\n\r\n(type (int 0))\r\n;=> java.lang.Integer\r\n\r\n(type (short 0))\r\n;=> java.lang.Short\r\n\r\n(type (byte 0))\r\n;=> java.lang.Byte\r\n\r\n;; decimal, hexadecimal, octal, radix-32, and binary literals:\r\n[127 0x7F 0177 32r3V 2r01111111]\r\n;=> [127 127 127 127 127]\r\n;; radix supports up to base 36\r\n\r\n(Short/MAX_VALUE)\r\n;=> 32767\r\n\r\n(Integer/MAX_VALUE)\r\n;=> 2147483647\r\n\r\nByte/MAX_VALUE\r\n;=> 127\r\n\r\n(type 1.23)\r\n;=> java.lang.Double\r\n\r\n(type (float 1.23))\r\n;=> java.lang.Float\r\n\r\n366e3\r\n;=> 366000.0\r\n```\r\n\r\n\r\n```clj\r\n(+ 1 2.0)\r\n;=> 3.0\r\n\r\n(class (+ 1 2.0))\r\n;=> java.lang.Double\r\n\r\n(= 3 3.0)\r\n;=> false\r\n\r\n(== 3 3.0)\r\n;=> true\r\n\r\n(* 2 3 1/5)\r\n;=> 6/5\r\n\r\n(- 5 1 1 1)\r\n;=> 2\r\n\r\n(- 2)\r\n;=> -2\r\n\r\n(* 4)\r\n;=> 4\r\n\r\n(/ 4)\r\n;=> 1/4\r\n\r\n(+)\r\n;=> 0     ;neutral for addition\r\n\r\n(*)\r\n;=> 1     ;neutral for multiplication\r\n\r\n(<= 1 2 3)\r\n;=> true\r\n\r\n(<= 1 3 2)\r\n;=> false\r\n\r\n(= 2 2 3)\r\n;=> false\r\n\r\n(= 2 2 2)\r\n;=> true\r\n```\r\n\r\nTo avoid having to round floating-point numbers (e.g. result of `2 / 3`), Clojure provides a **rational** number type `clojure.lang.Ratio`, thus maintaining absolute precision when dealing with floating point arithmetic:\r\n\r\n```clj\r\n(type 1/3)\r\n;=> clojure.lang.Ratio\r\n\r\n;; rational numbers are automatically simplified, if possible:\r\n100/25\r\n;=> 4\r\n\r\n(rational? 2)   ;is rational or may be rational\r\n;=> true\r\n\r\n(rational? 2.1)\r\n;=> false\r\n\r\n(rationalize 2.1)\r\n;=> 21/10\r\n\r\n(numerator (/ 21 10))\r\n;=> 21\r\n\r\n(denominator (/ 21 10))\r\n;=> 10\r\n```\r\n\r\n> The calculation of rational math, though accurate, isn’t nearly as fast as with floats or doubles (due to overhead cost of e.g. finding the least common denominator).\r\n\r\n**Truncation**\r\n\r\nTruncation is a process of limiting the accuracy of floating-point numbers, due to deficiencies in its representation. When a number is truncated, its precision is limited such that the maximum number of digits of accuracy is bound by the number of bits that can fit into the storage space allowed by its representation.\r\n\r\n```clj\r\n(let [pi-constant 3.14159265358979323846264338327950288419716939937M] ;notice the M\r\n  (println (class pi-constant))\r\n  pi-constant)\r\n;=> java.math.BigDecimal\r\n;=> 3.14159265358979323846264338327950288419716939937M\r\n\r\n(let [pi-trunc 3.14159265358979323846264338327950288419716939937]\r\n  (println (class pi-trunc))\r\n  pi-trunc)\r\n;=> java.lang.Double\r\n;=> 3.141592653589793\r\n```\r\n\r\n`M`, at the end of a floating-point number literal is used to tell Clojure to keep the number in its full precision.  \r\n`N` is used for the same thing when dealing with longs.\r\n\r\n> Clojure truncates floating point numbers by default\r\n\r\n**Promotion**\r\n\r\nClojure is able to detect when overflow occurs. Then, it automatically promotes the value to a numerical representation that can accommodate larger values\r\n\r\n```clj\r\n(def small 9)\r\n(class small)\r\n;=> java.lang.Long\r\n\r\n(class (+ small 90000000000000000000))\r\n;=> clojure.lang.BigInt\r\n\r\n(class (+ small 9.0))\r\n;=> java.lang.Double\r\n\r\n(+ Integer/MAX_VALUE Integer/MAX_VALUE)\r\n;=> 4294967294\r\n\r\n(class (+ Integer/MAX_VALUE Integer/MAX_VALUE))\r\n;=> java.lang.Long\r\n```\r\n\r\n> There's no limit to integer size in Clojure, besides RAM size\r\n\r\n### Strings and Characters\r\n\r\nString is any sequence of characters enclosed in double quotes, including newlines:\r\n\r\n```clj\r\n\"this is a string\r\non two lines\"\r\n;=> \"this is a string\\non two lines\"  ;REPL output includes newline escape\r\n\r\n(type \"a\")\r\n;=> java.lang.String\r\n\r\n(str nil)    ;'nil' is Clojure's 'null'\r\n;=> \"\"\r\n```\r\n\r\n> single quote, backtick and `quote` (though with slightly different properties) are used to include literals in a program without evaluating them\r\n\r\n```clj\r\n(str 'cat)\r\n;=> \"cat\"\r\n\r\n(str 'a')\r\n;=> \"a'\"\r\n\r\n(str 1)\r\n;=> \"1\"\r\n\r\n(str '1)\r\n;=> \"1\"\r\n\r\n(str true)\r\n;=> \"true\"\r\n\r\n(str '(1 2 3))\r\n;=> \"(1 2 3)\"\r\n\r\n(str \"meow \" 3 \" times\")\r\n;=> \"meow 3 times\"\r\n\r\n;characters are denoted by backslash\r\n\\a\r\n;=> \\a\r\n\r\n\\u0042\r\n;=> \\B\r\n\r\n\\\\\r\n;=> \\\\\r\n```\r\n\r\n## Symbols\r\n\r\nSymbols can have either short or full names. The short name is used to refer to things locally, and the _fully qualified name_ is used to refer unambiguously to a symbol (from anywhere).\r\nSymbol names are separated with a `/`. For instance, the symbol `str` is also present in a namespace called `clojure.core` and the corresponding full name is `clojure.core/str`\r\nThe main purpose of symbols is to refer to _things_, i.e. to point to other values. When evaluating a program, symbols are looked up and replaced by their corresponding values. \r\n\r\n> [more about symbols](#symbols)\r\n\r\n```clj\r\n(= str clojure.core/str)\r\n;=> true\r\n\r\n(name 'clojure.core/str)\r\n;=> \"str\"\r\n```\r\n\r\n\r\n## Keywords\r\n\r\nClosely related to symbols and strings are keywords, which begin with a `:`.  \r\nKeywords are like strings in that they are made up of text, but are specifically intended for use as labels or identifiers. These are not labels in the sense of symbols, keywords are not replaced by any other value, they are just names, by themselves:\r\n\r\n```clj\r\n(type :cat)\r\n;=> clojure.lang.Keyword\r\n\r\n(str :cat)\r\n;=> \":cat\"\r\n\r\n(name :cat)\r\n;=> \"cat\"\r\n```\r\n\r\n**Using keywords as map keys**\r\n\r\n> since keywords are self-evaluating and provide fast equality checks, they are almost always used as map keys\r\n\r\nAnother important property of keywords, when used as map keys, is that they can be used as functions, taking a map as an argument to perform value lookups:\r\n\r\n```clj\r\n(def mouse-planet {:cats 180, :mice 9})   ;define a map\r\n;=> #'user/mouse-planet\r\n\r\n(:cats mouse-planet)                      ;lookup by keyword\r\n;=> 180\r\n\r\n(println (/ (:cats mouse-planet)          ;much more useful example\r\n            (:mice mouse-planet))\r\n         \"cats per capita\")\r\n;=> 20 cats per capita\r\n```\r\n\r\n**As enumerations**\r\n\r\nSince their value doesn't change, convenient keyword use case is enumeration. E.g. `:mouse`, `:rat` and `:x-rat` provide a nice visual delineation (for mouse types) within a source code.\r\n\r\n> there are other useful things we can do with keywords. We can use them **As multimethod dispatch values** and **As directives**, but we'll deal with that later\r\n\r\n**Qualifying your keywords**\r\n\r\nKeywords don't belong to any specific namespace, although it's a good practice to define them as if they do, because that way you provide a context:\r\n\r\n```clj\r\nuser=> :not-in-ns\r\n;=> :not-in-ns\r\n\r\nuser=> ::not-in-ns          ;fully qualified keyword\r\n;=> :user/not-in-ns\r\n\r\nuser=> (ns another)\r\n;=> nil\r\n\r\nanother=> :user/in-another  ;\"fully qualified\" keyword\r\n;=> :user/in-another\r\n\r\nanother=> :haunted/name     ;namespace doesn't have to exist\r\n;=> :haunted/name\r\n```\r\n\r\n> double colon is used to fully qualify a keyword by prepending the current namespace name to the keyword name\r\n\r\n> equally named keywords are the same object in memory\r\n\r\n## Booleans\r\n\r\nOnly `false` and `nil` are logical `false`, all others values are `true`:\r\n\r\n```clj\r\n(boolean nil)\r\n;=> false\r\n\r\n(boolean 0)\r\n;=> true\r\n\r\n(boolean \"hi\")\r\n;=> true\r\n\r\n(boolean str)\r\n;=> true\r\n\r\n(and true false true)\r\n;=> false\r\n\r\n(and true true true)\r\n;=> true\r\n```\r\n\r\n... and returns the first _falsy_ value, or the last value if all are _truthy_:\r\n```clj\r\n(and 1 2 3)\r\n;=> 3\r\n\r\n(and -1 nil 2)\r\n;=> nil\r\n```\r\n\r\nor returns the first _truthy_ value, or the last value if all are _falsy_:\r\n```clj\r\n(or false 2 3)\r\n;=> 2\r\n\r\n(or false false nil)\r\n;=> nil\r\n```\r\n\r\n`not` inverses the _truthiness_ of the expression:\r\n```clj\r\n(not nil)\r\n;=> true\r\n```\r\n\r\n## Regular expressions\r\n\r\n`#\"...\"` is Clojure’s way of writing a regular expression.  \r\nClojure and Java have very similar Regex syntax.\r\n\r\n```clj\r\n(re-find #\"cat\" \"mystic cat mouse\")\r\n;=> \"cat\"\r\n\r\n(re-find #\"cat\" \"only dogs here\")\r\n;=> nil\r\n```\r\n\r\nThe parentheses, i.e. _capturing group_ means that the regular expression should capture that part of the match. We get back a _list_ containing the part of the string that matched the first parentheses, followed by the part that matched the second parentheses, etc:\r\n\r\n```clj\r\n(re-matches #\"(.+):(.+)\" \"mouse:treat\")\r\n;=> [\"mouse:treat\" \"mouse\" \"treat\"]\r\n\r\n;; capturing group in the regex causes each returned item to be a vector:\r\n(re-seq #\"\\w*(\\w)\" \"one-two/three\")\r\n;=> ([\"one\" \"e\"] [\"two\" \"o\"] [\"three\" \"e\"])\r\n```\r\n\r\nJava's regex `Pattern` class has several methods that can be used directly, but only `split` is used regularly to split a string into an array of Strings:\r\n\r\n```clj\r\n(seq (.split #\",\" \"1,2,3,4\"))  ;this is how you call Java methods\r\n;=> (\"1\" \"2\" \"3\" \"4\")\r\n```\r\n\r\n[Java interoperability section.](#java-interop)  \r\n\r\nThe `re-seq` function returns a lazy sequence of all matches in a string:\r\n\r\n```clj\r\n(re-seq #\"\\w+\" \"one-two/three\")\r\n;=> (\"one\" \"two\" \"three\")\r\n```\r\n\r\n> Java's regex engine includes a `Matcher` object which mutates in a non-thread-safe way as it walks through a string finding matches. This object is exposed in Clojure through the `re-matcher` function and can be used in combination with `re-groups` and `re-find`.\r\nIt's recommended to avoid direct usage of all of these three functions.\r\n\r\n# Collections\r\n\r\nA collection is a group of values. It’s a container which provides some structure, some framework, for the things that it holds. We refer to collection members as elements, or items.\r\n\r\nAll Clojure's collections support heterogeneous values (values of arbitrary types), together, in the same collection.\r\n\r\n> when a collection is evaluated (except lists), each of its contained items is evaluated first\r\n\r\nMost of functions that work on collections aren't actually written to work on concrete collection types, but rather to work on abstract data types. For instance, some of abstractions in this space are:\r\n\r\n - Collection  (common to all concrete types)\r\n - Sequential  (ordered collections are lists and vectors)\r\n - Associative (maps associate keys with values, vectors associate indices with values)\r\n - Indexed     (vectors, for example, can be quickly indexed into)\r\n\r\n## Lists\r\n\r\nA `PersistentList` is a singly linked list where each node knows its distance from the end. \r\nList elements can only be found by starting with the first element and walking each prior node in order. \r\nList elements can only be added or removed from the left end.\r\n\r\nIn idiomatic Clojure code, lists are used almost exclusively to represent code forms, e.g. to call functions, macros, ...\r\nCode forms are then `eval`-ed or used as the return value for a macro.\r\n\r\n> Lists are rarely used for anything other than to represent Clojure source code, because they rarely offer any value over vectors\r\n\r\nLiteral lists are written with parentheses: `(yankee hotel foxtrot)`.\r\n\r\nWhen a list is evaluated, the first item of the list, `yankee`, will be resolved to a _function_, _macro_, or _special form_. \r\nIf `yankee` is a _function_, the remaining items in the list will be evaluated in order, and the results will be passed to `yankee` as its parameters.\r\nIf `yankee` is a _macro_ or a _special form_, the remaining items in the list\r\naren’t necessarily evaluated, but are processed as defined by the _macro_ or _operator_.\r\n\r\n> **special form** is a form with special syntax or special evaluation rules that are typically not implemented using the base Clojure forms. An example of a special form is\r\nthe `.` (dot) operator used for Java interoperability purposes.\r\n\r\n```clj\r\n(cons 1 (2 3))\r\n\r\n;=> ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn\r\n;;which basically means that the number 2 cannot be used as a function\r\n\r\n(cons 1 '(2 3))\r\n;=> (1 2 3)\r\n```\r\n\r\nRemember, we quote lists (any everything else needed quoting) with a `'` (or `quote`) to prevent them from being evaluated.  \r\n\r\n```clj\r\n'(1 2 3)\r\n;=> (1 2 3)\r\n\r\n(type '(1 2 3))\r\n;=> clojure.lang.PersistentList\r\n```\r\n\r\nThere's also a **syntax-quote** (back-tick), which automatically qualifies all unqualified symbols in its argument:\r\n\r\n```clj\r\n`map\r\n;=> clojure.core/map\r\n\r\n`(map even? [1 2 3])\r\n;=> (clojure.core/map clojure.core/even? [1 2 3])\r\n```\r\n\r\nYou can also construct a list using `list`:\r\n\r\n```clj\r\n(list 1 2 3)\r\n(1 2 3)\r\n(= (list 1 2) (list 1 2))\r\ntrue\r\n```\r\n\r\nYou can modify a list by _conjoining_ an element onto it (as always with lists, the new element goes to the beginning):\r\n\r\n```clj\r\n(conj (list 1 2 3) 4)\r\n;=> (4 1 2 3)\r\n\r\n(first (list 1 2 3))\r\n;=> 1\r\n\r\n(second (list 1 2 3))\r\n;=> 2\r\n\r\n(nth (list 1 2 3) 2)\r\n;=> 3\r\n```\r\n\r\nUnlike some _Lisps_, the empty list in Clojure, `()`, isn't the same as `nil`.\r\nLists are well-suited for small collections, or collections which are read in linear order, but are slow when you want to get arbitrary elements from later in the list. \r\n\r\n> Calling `seq` on a list returns the list itself, but more often, calling `seq` on a collection returns a new `seq` object for navigating that collection.\r\n\r\n### What lists aren't?\r\n\r\nProbably the most common misuse of lists is to hold items that will be looked up by index. Though you can use `nth` to get the element, Clojure will have to walk the list from the beginning to find it.  \r\n\r\nLists aren't queues. You can add items to one end, but you can't remove from the other.\r\n\r\n### PersistentQueue\r\n\r\nPersistent immutable queue is a FIFO structure where `conj` adds to the rear, `pop` removes from the front and `peek` returns the front element without removal.\r\n\r\nClojure currently doesn't provide a core construction function for creating persistent queues, but there's a readily available empty queue instance to use, `clojure.lang.PersistentQueue/EMPTY`.\r\n\r\nThe printed representation for Clojure's queues isn't particularly informative, but we can change that by providing a method for them on the `print-method`:\r\n\r\n```clj\r\n(defmethod print-method clojure.lang.PersistentQueue\r\n  [q, w]\r\n  (print-method '<- w) (print-method (seq q) w) (print-method '-< w))\r\n\r\nclojure.lang.PersistentQueue/EMPTY\r\n;=> <-nil-<\r\n```\r\n\r\n> Popping an empty queue results in just another empty queue. Peeking an empty queue returns `nil`\r\n\r\nThe mechanism for adding an element to a queue is `conj`:\r\n\r\n```clj\r\n(def tasks\r\n  #_=>   (conj clojure.lang.PersistentQueue/EMPTY\r\n  #_=>         :wake-up :shower :brush-teeth))\r\n;=> #'mbo/tasks\r\n\r\ntasks\r\n;=> <-(:wake-up :shower :brush-teeth)-<\r\n```\r\n\r\n> Clojure's persistent queue is implemented internally using two separate collections, the front being a seq and the rear being a vector. All insertions occur in the rear vector and all removals occur in the front seq, taking advantage of each collection's strength. When all the items from the front have been popped, the back vector is wrapped in a seq to become the new front and an empty vector is used as the new back\r\n\r\nTo get the front element, we use `peek`:\r\n\r\n```clj\r\n(peek tasks)\r\n;=> :wake-up\r\n```\r\n\r\nTo remove elements from the front of a queue, we use `pop` (although possible, it's non-idiomatic and suboptimal to use `rest` with queues, because it returns a seq, not a queue and _fucks up_ the speed guarantees):\r\n\r\n```clj\r\n(pop tasks)\r\n;=> <-(:shower :brush-teeth)-<\r\n\r\n(rest tasks)\r\n;=> (:shower :brush-teeth)\r\n```\r\n\r\n## Vectors\r\n\r\nFor fast access to every element, we use a __vector__.\r\nVectors are surrounded by square brackets, just like lists are surrounded by parentheses. Because vectors aren’t evaluated like lists are, there is no need to quote the vector literal:\r\n\r\n```clj\r\n[1 2 3]\r\n;=> [1 2 3]\r\n\r\n(type [1 2 3])\r\n;=> clojure.lang.PersistentVector\r\n```\r\n\r\n> Vectors are similar to arrays, but are immutable and persistent\r\n\r\nYou can also create vectors with `vector`, or change other structures into vectors with `vec`:\r\n\r\n```clj\r\n(vector 1 2 3)\r\n;=> [1 2 3]\r\n\r\n(vec (list 1 2 3))\r\n;=> [1 2 3]\r\n```\r\n\r\n`conj` on a vector adds to the end, not the start, like with lists:\r\n\r\n```clj\r\n(conj [1 2 3] 4)\r\n;=> [1 2 3 4]\r\n```\r\n\r\nOur friends `first`, `second`, and `nth` work here too; but unlike lists, `nth` is fast on vectors. That’s because internally, vectors are represented as a very broad tree of elements, where each part of the tree branches into 32 smaller trees. Even very large vectors are only a few layers deep, which means getting to elements only takes a few hops, which is why retrieval operation from the interior of a vector takes essentially a constant time.\r\n\r\nThe important difference, when compared to lists, is that vectors evaluate each item in order. No function or macro is performed on a vector itself.\r\n\r\n`rest` and `next` both return _everything but the first element_. They differ only by what happens when there are no remaining elements:\r\n\r\n```clj\r\n(rest [1 2 3 4])\r\n;=> (2 3 4)\r\n\r\n(next [1 2 3 4])\r\n;=> (2 3 4)\r\n```\r\n\r\n`rest` returns logical `true`, `next` returns logical `false`. Each has their uses, but in almost every case they’re equivalent:\r\n\r\n```clj\r\n(next [1])\r\n;=> nil\r\n\r\n(rest [1])\r\n;=> ()\r\n```\r\n\r\n`last`, surprisingly, returns the last element:\r\n\r\n```clj\r\n(last [1 2 3])\r\n;=> 3\r\n```\r\n\r\n`count`, shockingly, returns element count:\r\n\r\n```clj\r\n(count [1 2 3 4])\r\n;=> 4\r\n```\r\n\r\nYou can use element's index to access it:\r\n\r\n```clj\r\n([1 2 3] 1)  ;vectors are in fact functions of their indices\r\n;=> 2\r\n```\r\n\r\nVectors and lists containing the same elements are considered equal:\r\n\r\n```clj\r\n(= [1 2] (list 1 2))\r\n;=> true\r\n```\r\n\r\nIf you already have a vector but want to \"pour\" several values into it, use `into`:\r\n\r\n```clj\r\n(let [m-vector [:a :b :c]]\r\n  (into m-vector (range 10)))\r\n;=> [:a :b :c 0 1 2 3 4 5 6 7 8 9]\r\n\r\n;;if you want to return a vector the first arg to 'into' must be a vector\r\n;;the second argument must be anything that works with 'seq' function\r\n```\r\n\r\n### Primitive vectors\r\n\r\nYou can store primitive types inside of vectors using the `vector-of` function, which takes any of `:int`, `:long`, `:float`, `:double`, `:byte`, `:short`, `:boolean` and `:char` and returns an empty vector. This returned vector will act just like any other vector, except that, internally, it'll store its contents as primitives.  \r\nThe new vector will try to coerce any additions into its internal type when they are being added:\r\n\r\n```clj\r\n(into (vector-of :int) [Math/PI 2 1.3])\r\n;=> [3 2 1]\r\n\r\n(into (vector-of :char) [100 101 102])\r\n;=> [\\d \\e \\f]\r\n\r\n(into (vector-of :int) [1 2 609812734019519652839108477134])\r\n\r\n;=> IllegalArgumentException Value out of range for long: 60981273401951...\r\n;=> clojure.lang.RT.longCast (RT.java:1134)\r\n```\r\n\r\n### Large vectors\r\n\r\nVectors are particularly efficient at three things (relative to lists): \r\n - adding or removing things from the right end of the collection\r\n - accessing or changing items in the interior of the collection by numeric index\r\n - walking in reverse order\r\n\r\n```clj\r\n(def a-to-e (vec (map char (range 65 91))))\r\n;=> #'mbo/a-to-z\r\n\r\na-to-e\r\n;=> [\\A \\B \\C \\D \\E]\r\n\r\n(nth a-to-e 4)   ;like with a map\r\n;=> \\E\r\n\r\n(get a-to-e 4)   ;like with a map\r\n;=> \\E\r\n\r\n(a-to-e 4)       ;invoking a vector as a function\r\n;=> \\E\r\n```\r\n\r\n![vector-lookup-options](https://github.com/mbonaci/clojure/raw/master/resources/vector-lookup-options.png)\r\n\r\nSince vectors are indexed, they can be efficiently walked in either direction. The `seq` and `rseq` return sequences that do exactly that:\r\n\r\n```clj\r\n(seq a-to-e)\r\n;=> (\\A \\B \\C \\D \\E)\r\n\r\n(rseq a-to-e)\r\n;=> (\\E \\D \\C \\B \\A)\r\n```\r\n\r\nAny item in a vector can be \"changed\" using the `assoc` function (in a constant time). Clojure does this using _structural sharing_ between the old and the new vectors, hence avoiding having to copy all the elements.\r\n\r\n```clj\r\n(assoc a-to-e 3 \"former D\")\r\n;=> [\\A \\B \\C \"former D\" \\E]\r\n```\r\n\r\nThe `assoc` function works only on indices that either already exist or, as a special case, exactly one step past the end of a vector (returned vector becomes one item larger).\r\n\r\nFunction `replace` uses `assoc` internally:\r\n\r\n```clj\r\n(replace {2 :a, 4 :b} [1 2 3 2 3 4])\r\n;=> [1 :a 3 :a 3 :b]\r\n```\r\n\r\nThe functions `assoc-in`, `update-in` and `get-in` are used to work with nested structures of vectors and/or maps. These functions take a series of indices to pick items from each more deeply nested level:\r\n\r\n```clj\r\n(def matrix\r\n  [[1 2 3]\r\n   [4 5 6]\r\n   [7 8 9]])\r\n;=> #'mbo/matrix\r\n\r\n(get-in matrix [1 2])   ;second row, third column\r\n;=> 6\r\n\r\n(assoc-in matrix [1 2] 'x)\r\n;=> [[1 2 3] [4 5 x] [7 8 9]]\r\n```\r\n\r\n`update-in` works the similar way, but instead of taking a value to \"overwrite\" an existing value, it takes a function to _apply_ to an existing value. It'll replace the value at the given coordinates with the return value of the function:\r\n\r\n```clj\r\n(update-in matrix [1 2] * 100)\r\n;=> [[1 2 3] [4 5 600] [7 8 9]]\r\n\r\n;; the coordinates refer to the value 6 and the function is * taking an argument 100\r\n;; so the slot becomes the return value of (* 6 100)\r\n```\r\n\r\nRemember? `matrix` itself never changed:\r\n\r\n```clj\r\nmatrix\r\n;=> [[1 2 3] [4 5 6] [7 8 9]]\r\n```\r\n\r\n### Vectors as stacks\r\n\r\nClojure vectors uses `conj` as `push` and `pop` as `pop` to add and remove elements from the right side. Since vectors are immutable, `pop` returns a new vector with the rightmost element dropped, which is different from many mutable stack APIs, which generally return the dropped item. Consequently, `peek` becomes more important as the primary way to get an item from the top of the stack:\r\n\r\n```clj\r\n(peek m-stack)\r\n;=> 3\r\n\r\n(pop m-stack)\r\n;=> [1 2]\r\n\r\n(conj m-stack 4)\r\n;=> [1 2 3 4]\r\n\r\n(+ (peek m-stack) (peek (pop m-stack)))\r\n;=> 5\r\n```\r\n\r\n> If you're using a collection (any implementor of `clojure.lang.IPersistentStack`) as a stack, it's idiomatic to use `conj` instead of `assoc`, `peek` instead of `last` and `pop` instead of `dissoc`. That avoids unnecessary confusion about how the collection is being used\r\n  \r\n> Lists also implement `IPersistentStack`, but the functions there operate on the left side, i.e. beginning of the list\r\n\r\n### Using vectors instead of reverse\r\n\r\nWhen processing a list, it's pretty common to want to produce a new list in the same order. But if all you have is list, then you're left with backward list that needs to be reversed:\r\n\r\n```clj\r\n(defn m-map1 [f coll]\r\n  (loop [coll coll, acc nil]\r\n\t(if (empty? coll)\r\n\t  (reverse acc)\r\n\t  (recur (next coll) (cons (f (first coll)) acc)))))\r\n;=> #'mbo/m-map1\r\n\r\n(m-map1 - (range 5))\r\n;=> (0 -1 -2 -3 -4)\r\n```\r\n\r\nAfter the entire list has been walked once to produce the desired values, `reverse` walks it again to get them in the right order, which is inefficient and non-idiomatic.\r\nOne way to avoid `reverse` is to use a vector as the accumulator, instead of a list:\r\n\r\n```clj\r\n(defn m-map2 [f coll]\r\n  (loop [coll coll, acc []]\r\n\t(if (empty? coll)\r\n\t  acc\r\n\t  (recur (next coll) (conj acc (f (first coll)))))))\r\n;=> #'mbo/m-map2\r\n\r\n(m-map2 - (range 5))\r\n;=> [0 -1 -2 -3 -4]\r\n```\r\n\r\n### Subvectors\r\n\r\nProvide a fast way to take a slice of an existing vector based on start and end indices.\r\nTo produce a subvector we use the `subvec` function:\r\n\r\n```clj\r\n(subvec a-to-e 2 4)\r\n;=> [\\C \\D]\r\n\r\n;;first index is inclusive, but the second is exclusive\r\n```\r\n\r\n> There's a special logic for taking a `subvec` of a `subvec`, in which case the newest subvector keeps a reference to the original vector, not the intermediate subvector, which keeps both the creation and use of sub-subvectors fast and efficient.\r\n\r\n### Vectors as MapEntries\r\n\r\nClojure's hash map, just like hash tables and dictionaries in many other languages, has a mechanism to iterate through the entire collection. Clojure's solution for this iterator is, you guessed it - `seq`.  \r\nEach item in this seq needs to include both the key and the value, hence they are wrapped in a `MapEntry`. When printed, each entry looks like a vector:\r\n\r\n```clj\r\n(first {:width 10 :height 20 :depth 15})\r\n;=> [:depth 15]\r\n\r\n;;not only does it look like a vector, it really is one:\r\n(vector? (first {:width 10 :height 20 :depth 15}))\r\n;=> true\r\n\r\n;;which means you can use all the regular vector functions on it\r\n;;it even supports destructuring*\r\n```\r\n\r\n[destructuring?](#destructuring)\r\n\r\n```clj\r\n;;e.g. the following locals, 'dimension' and 'amount', will take on the value of each\r\n;;key/value pair in turn:\r\n(doseq [[dimension amount] {:width 10, :height 20, :depth 15}]\r\n  (println (str (name dimension) \":\") amount \" inches\"))\r\n;=> depth: 15  inches\r\n;=> width: 10  inches\r\n;=> height: 20  inches\r\n;=> nil\r\n\r\n(doc doseq)\r\n;=> -------------------------\r\n;=> clojure.core/doseq\r\n;=> ([seq-exprs & body])\r\n;=> Macro\r\n;=>   Repeatedly executes body (presumably for side-effects) with\r\n;=>   bindings and filtering as provided by \"for\".  Does not retain\r\n;=>   the head of the sequence. Returns nil.\r\n```\r\n\r\nA `MapEntry` is its own type and has two functions for retrieving its contents, `key` and `val`, which do exactly the same thing as `(nth m-map 0)` and `(nth m-map 1)`.\r\n\r\n### What vectors aren't?\r\n\r\nVectors are versatile, but there are some useful patterns where they might seem like a good fit, but in fact the aren't.\r\n\r\n**Vectors aren't sparse**\r\n\r\nIf you have a vector of length _n_, the only position where you can insert a value is at index _n_, appending to the far right end. You can't skip some indices and insert at a higher index number (use hash map or sorted map).  \r\nAlthough you can replace values within a vector, you can't insert or delete items such that indices are adjusted (use finger trees for that).\r\n\r\n**Vectors aren't queues**\r\n\r\nUse a [PersistentQueue](#persistentqueue) for that.\r\n\r\n**Vectors aren't sets**\r\n\r\nIf you want to find out whether a vector contains a particular value, you might be tempted to use the `contains?` function, but that function checks whether a specific _key_, not _value_ is in a collection, which is really not useful for a vector.\r\n\r\n> Vectors are probably the most frequently used collection type in Clojure. They are used as literals for argument lists and `let` bindings, for holding large amounts of application data and as stacks and map entries\r\n  \r\n> In almost all contexts, you can consider vectors, lists, and other sequences as interchangeable. They only differ in their performance characteristics, and in a few data-structure-specific operations.\r\n\r\n## Sets\r\n\r\nSet is a collection of unordered, unique elements.\r\n\r\nSets are surrounded by `#{...}`:\r\n\r\n```clj\r\n#{1 2 3}\r\n;=> #{1 2 3}\r\n\r\n(#{:a :b :c :d} :c)\r\n;=> :c\r\n\r\n(#{:a :b :c :d} :e)\r\n;=> nil\r\n```\r\n\r\nIf you look at the previous two expressions, you'll see that the sets are in fact functions of their elements that return the matched element or `nil` if the element is not present (take a pause and read that a couple more times, examining the examples).\r\n\r\nElements can be accessed via the `get` function, which returns the queried value if it exists, or `nil` if it doesn't:\r\n\r\n```clj\r\n(get #{:a 1 2 :b} :b)\r\n;=> :b\r\n\r\n(get #{:a 1 2 :b} :k)\r\n;=> nil\r\n```\r\n\r\n**Searching a sequence for any of multiple items using a set and `some`**\r\n\r\nThe `some` function takes a predicate and a sequence. It applies the predicate to each element in turn, returning the first _truthy_ value returned by the predicate or else `nil`:\r\n\r\n```clj\r\n(some #{:b} [:a 1 :b 2])\r\n;=> :b\r\n\r\n(some #{1 :b} [:a 1 :b 2])\r\n;=> 1\r\n```\r\n\r\nUsing a set as the predicate supplied to `some` allows you to check whether any of the truthy values in the set are contained within the given sequence. This is a frequently used Clojure idiom for searching for containment within a sequence.\r\n\r\nThe key to understanding how sets determine whether an element is discrete lies in one simple statement: Given two elements, evaluating as equal, a set will contain only one, independent of concrete types:\r\n\r\n```clj\r\n(let s #{[1 2] (1 2)})  ;vector and list with the same items are considered equal\r\n\r\n;=> IllegalArgumentException Duplicate key: (1 2)\r\n;=> clojure.lang.PersistentHashSet.createWithCheck (PersistentHashSet.java:68)\r\n```\r\n\r\n**Sorted sets**\r\n\r\nTo ask for elements in a sorted order:\r\n\r\n```clj\r\n(sort #{2 4 1})\r\n;=> (1 2 4)\r\n```\r\n\r\nAs long as the arguments to the `sorted-set` function are mutually comparable, you'll receive a sorted set. Otherwise an exception is thrown:\r\n\r\n```clj\r\n(sorted-set :b :c :a)\r\n;=> #{:a :b :c}\r\n\r\n(sorted-set [3 4] [1 2])\r\n;=> #{[1 2] [3 4]}\r\n\r\n(sorted-set :b 2 :c)\r\n\r\n;=> ClassCastException clojure.lang.Keyword cannot be cast to java.lang.Number\r\n;=> clojure.lang.Util.compare (Util.java:152)\r\n```\r\n\r\nYou can use your own comparator with `sorted-set-by` function.\r\n\r\n**Containment**\r\n\r\n`contains?` checks for **existence of a key** in a collection:\r\n\r\n```clj\r\n(contains? #{1 2 3} 3)\r\n;=> true\r\n```\r\n\r\nMany newcomers to Clojure expect `contains?` to behave the same as Java's `java.util.Collection#contains` method, but it doesn't:\r\n\r\n```clj\r\n(contains? [1 2 4 3] 4)\r\n;=> false\r\n```\r\n\r\nSince `contains?` looks for existence of a key it shouldn't work with sets, but it does. That is due to the fact that sets are implemented as maps with the same element as the _key_ and _value_ with an additional check for containment before insertion.\r\n\r\n### `clojure.set` namespace\r\n\r\n`clojure.set/intersection` function works as you might expect. Given two sets, it returns a set of the common elements. Given _n_ sets, it'll incrementally return the intersection of resulting sets and the next set:\r\n\r\n```clj\r\n(clojure.set/intersection #{:a :b :c} #{:d :c :b})\r\n;=> #{:b :c}\r\n\r\n(clojure.set/intersection #{:a :e :i :o :u}\r\n\t\t\t\t\t\t  #{:a :u :r}\r\n\t\t\t\t\t\t  #{:r :u :s})\r\n;=> #{:u}\r\n```\r\n\r\n`clojure.set/union` works as expected.  \r\n`clojure.set/difference` \"removes\" all the elements from the first set that are also present in the second set (known as _relative complement_).\r\n\r\n`conj` \"adds\" an element to the set:\r\n\r\n```clj\r\n(conj #{:a :b :c} :d)\r\n;=> #{:a :c :b :d}\r\n```\r\n\r\n`disj` \"removes\" an element:\r\n\r\n```clj\r\n(disj #{1 2} 2)\r\n;=> #{1}\r\n```\r\n\r\nYou can make a set out of any other collection with `set`:\r\n\r\n```clj\r\n(set [2 5 1])\r\n;=> #{1 2 5}\r\n```\r\n\r\n## Maps\r\n\r\nMap is an unsorted, associative _key/value_ structure (associates keys with values).\r\nMaps are represented with curly braces `{...}` filled by alternating _key/value_ pairs, with or without commas:\r\n\r\n```clj\r\n{:name \"luka\", :weight 3 :color \"white\"}   ;notice missing comma\r\n;=> {:weight 3, :name \"luka\", :color \"white\"}\r\n```\r\n\r\nWe can look up the _value_ by _key_ with `get`:\r\n\r\n```clj\r\n(get {\"cat\" \"meow\", \"dog\" \"woof\"} \"cat\")\r\n;=> \"meow\"\r\n```\r\n\r\n`get` can also take a default value to return instead of `nil`, if the key doesn’t exist:\r\n\r\n```clj\r\n(get {:k :v} :w :default)\r\n;=> :default\r\n```\r\n\r\nMaps can be used as verbs, directly:\r\n\r\n```clj\r\n({\"a\" 12, \"b\" 24} \"b\")  ;maps are functions of their keys\r\n;=> 24\r\n```\r\n\r\nKeywords can also be used as verbs, which look themselves up:\r\n\r\n```clj\r\n(:raccoon {:weasel \"queen\", :raccoon \"king\"})\r\n;=> \"king\"\r\n```\r\n\r\nIn addition to literal syntax, hash maps can be created with the `hash-map` function:\r\n\r\n```clj\r\n(hash-map :a 1, :b 2, :c 3, :d 4, :e 5)\r\n;=> {:a 1, :c 3, :b 2, :d 4, :e 5}\r\n```\r\n\r\nMaps support heterogeneous keys, which means that keys can be of any type and each key can be of a different type:\r\n\r\n```clj\r\n(let [m {:a 1, 1 :b, [1 2 3] \"4 5 6\"}]\r\n  [(get m :a) (get m [1 2 3])])\r\n;=> [1 \"4 5 6\"]\r\n\r\n;;which can also be written without 'get', using map as a function of its keys:\r\n(let [m {:a 1, 1 :b, [1 2 3] \"4 5 6\"}]\r\n  [(m :a) (m [1 2 3])])\r\n;=> [1 \"4 5 6\"]\r\n```\r\n\r\nProviding a map to a `seq` function returns a sequence of map entries:\r\n\r\n```clj\r\n(seq {:a 1, :b 2})\r\n;=> ([:a 1] [:b 2])   ;returns key/value pairs contained in vectors\r\n```\r\n\r\nA new hash map can be created idiomatically using `into`:\r\n\r\n```clj\r\n(into {} [[:a 1] [:b 2]])\r\n;=> {:a 1, :b 2}\r\n\r\n;;even if pairs aren't vectors, they can easily be made to be\r\n;;here, the map function, that has nothing to do with map-the-data-structure,\r\n;;applies 'vec' to all the elements:\r\n(into {} (map vec '[(:a 1) (:b 2)]))\r\n;=> {:a 1, :b 2}\r\n```\r\n\r\nIf the key/value pairs are laid out in a sequence consecutively, your pairs don't even have to be explicitly grouped. You can use `apply` to create a hash map:\r\n\r\n```clj\r\n(apply hash-map [:a 1 :b 2])\r\n;=> {:a 1, :b 2}\r\n```\r\n\r\nAnother idiomatic way to build a map is to use `zipmap` to \"zip\" together two sequences, the first of which contains keys and the second one values:\r\n\r\n```clj\r\n(zipmap [:a :b] [1 2])\r\n;=> {:b 2, :a 1}\r\n```\r\n\r\n`assoc` \"adds\" an element to a map: \r\n\r\n```clj\r\n(assoc {:bolts 1088} :camshafts 3)\r\n;=> {:camshafts 3, :bolts 1088}\r\n```\r\n\r\n`assoc` adds keys if they are not present, and replaces values if they are already there. If you associate a value onto `nil`, it creates a new map:\r\n\r\n```clj\r\n(assoc nil 5 2)\r\n;=> {5 2}\r\n```\r\n\r\n**Sorted maps**\r\n\r\nThe function `sorted-map` builds a map sorted by the comparison of its keys:\r\n\r\n```clj\r\n(sorted-map :b 1 :a 2 :c 0)\r\n;=> {:a 2, :b 1, :c 0}\r\n```\r\n\r\nIf you need alternative key ordering, or ordering for keys that are not naturally comparable, use `sorted-map-by`, which allows you to provide a comparison function:\r\n\r\n```clj\r\n(sorted-map-by #(compare (subs %1 1) (subs %2 1)) \"b\" 1 \"a\" 2)\r\n;=> {\"b\" 2}\r\n\r\n(doc subs)\r\n;-------------------------\r\n;clojure.core/subs\r\n;([s start] [s start end])\r\n;  Returns the substring of s beginning at start inclusive, and ending\r\n;  at end (defaults to length of string), exclusive.\r\n\r\n;;Explanation:\r\n;; by doing this:\r\n#(compare (subs %1 1) (subs %2 1))\r\n\r\n;; we declared an anonymous function inline, which is the same as writing:\r\n(defn m-compare [first second]\r\n  (compare (subs first 1) (subs second 1)))\r\n\r\n;; and then passing that function to sorted-by-map:\r\n(sorted-map-by m-compare \"b\" 1 \"a\" 2)\r\n;=> {\"b\" 2}\r\n```\r\n\r\n\r\n`merge` yields a map containing all the elements of all given maps, preferring the values from later ones:\r\n\r\n```clj\r\n(merge {:a 1, :b 2} {:b 3, :c 4})\r\n;=> {:c 4, :a 1, :b 3}\r\n```\r\n\r\nRemove map element with `dissoc`:\r\n\r\n```clj\r\n(dissoc {:a 1, :b 2, :c 4} :c)\r\n;=> {:a 1, :b 2}\r\n```\r\n\r\nLike vectors, any item in a map literal is evaluated before the result is stored in the map. Unlike vectors, the order in which they are evaluated isn't guaranteed.\r\n\r\n## Persistence\r\n\r\n> Persistent collections are immutable, in-memory (not on-disk) collections that allow you to preserve historical versions of their state.\r\n\r\nSince arrays are mutable, any changes happen in-place:\r\n\r\n```clj\r\n(def ds (into-array [:frane :luka :glupaca]))  ;mutable\r\n;=> #'mbo/ds\r\n\r\n;; btw Glupaca is the name of our cat (which means something like \"stupid women\")\r\n\r\n(seq ds)     ;only for nice REPL printout\r\n;=> (:frane :luka :glupaca)\r\n\r\n(aset ds 2 :suzi)   ;replace third element of the array\r\n;=> :suzi\r\n\r\n(seq ds)\r\n;=> (:frane :luka :suzi)\r\n```\r\n\r\nUsing one of Clojure's persistent data structures shows the difference:\r\n\r\n```clj\r\nmbo=> (def ds [:frane :luka :suzi])  ;init persistent collection\r\n;=> #'mbo/ds\r\n\r\nds                    ;print ds to REPL\r\n;=> [:frane :luka :suzi]\r\n\r\n(def ds8 (replace {:suzi :glupaca} ds))   ;replace third element and bind the\r\n;=> #'mbo/ds8                                 ;whole collection to ds8\r\n\r\nds                    ;ds did not change\r\n;=> [:frane :luka :suzi]\r\n\r\nds8                   ;the newly created collection\r\n;=> [:frane :luka :glupaca]\r\n```\r\n\r\n# Symbols\r\n\r\nClosest thing to a variable in Clojure. Primarily used to provide a name for a given value, i.e. to refer to function parameters, local variables, globals, and Java classes.\r\n\r\nUnlike keywords, symbols are not unique based solely on their names:\r\n\r\n```clj\r\n(identical? 'node 'node)\r\n;=> false\r\n\r\n;; identical? returns true only if symbols are the same object\r\n(let [x 'node y x] (identical? x y))\r\n;=> true\r\n```\r\n\r\nEach `node` symbol is a discrete object that only happens to share a name. Though name is the basis for symbol equality:\r\n\r\n```clj\r\n(= 'node 'node)\r\n;=> true\r\n\r\n(name 'node)\r\n;=> \"node\"\r\n```\r\n\r\nWe can define a meaning for a symbol within a specific expression, using `let`.\r\nThe `let` expression first **takes a vector of bindings**: alternating symbols and values that those symbols are bound to within the remainder of the expression.  \r\n\r\n“Let the symbol `cats` be `5`, and construct a string composed of `\"I have \"`, `cats`, and `\" cats\"`:\r\n\r\n```clj\r\n(let [mice 5] (str \"I have \" mice \" mice.\"))\r\n;=> \"I have 5 mice.\"\r\n```\r\n\r\nLet bindings, also called **locals**, apply only within the `let` expression itself. They also override any existing definitions for symbols at that point in the program. For example, we can redefine addition to mean subtraction, for the duration of a `let`:\r\n\r\n```clj\r\n(let [+ -] (+ 2 3))\r\n;=> -1\r\n```\r\n\r\nThat definition does not apply outside the `let`:\r\n\r\n```clj\r\n(+ 2 3)\r\n;=> 5\r\n```\r\n\r\nWe can also provide multiple bindings. Since Clojure doesn’t care about spacing, alignment, or newlines, we’ll write this on multiple lines, for clarity:\r\n\r\n```clj\r\n(let [person \"joseph\"\r\n\t   num-cats 186]\r\n   (str person \" has \" num-cats \" cats!\"))  ;the body\r\n;=> \"joseph has 186 cats!\"\r\n```\r\n\r\nWhen multiple bindings are given, they are evaluated in order. Later bindings can use previous bindings:\r\n\r\n```clj\r\n(let [cats 3\r\n\t   legs (* 4 cats)]\r\n (str legs \" legs all together\"))\r\n;=> \"12 legs all together\"\r\n```\r\n\r\n> a symbol whose name is prefixed with a namespace, followed by a slash, is called **fully qualified symbol**:\r\n\r\n```clj\r\nclojure.core/map\r\n;=> #<core$map clojure.core$map@2a0406c4>\r\n\r\nclojure.set/union\r\n;=> ;=> #<set$union clojure.set$union@1be2bcc8>\r\n```\r\n\r\nThe body is sometimes described as an _implicit do_ (see [blocks bellow](#blocks)) because it follows the same rules: you may include any number of expressions and all will be evaluated, but only the value of the last one is returned.\r\n\r\nBecause they’re immutable, _locals_ can’t be used to accumulate results. Instead,\r\nyou'd use a high level function or loop/recur form.\r\n\r\nTo summarize, `let` defines the meaning of symbols within an expression. When Clojure evaluates a `let`, it replaces all occurrences of those symbols in the rest of the `let` expression with their corresponding values, then evaluates the rest of the expression.\r\n\r\n**Metadata**\r\n\r\nClojure allows the attachment of metadata to various objects, including symbols. `with-meta` function takes an object and a map and returns another object of the same type with the metadata attached:\r\n\r\n```clj\r\n(let [x (with-meta 'node {:js true})    ;attach :js to 'node and assign to x\r\n\t  y (with-meta 'node {:js false})]\r\n  [(= x y)            ;true because they both hold the same symbol, 'node\r\n   (identical? x y)   ;false because they are different instances\r\n   (meta x)\r\n   (meta y)])\r\n;=> [true false {:js true} {:js false}]\r\n```\r\n\r\n**Symbols and namespaces**\r\n\r\nLike keywords, symbols don't belong to any specific namespace:\r\n\r\n```clj\r\nuser=> (ns what-where)\r\n;=> nil\r\n\r\nwhat-where=> (def one-simbol 'where-is-it)\r\n;=> #'what-where/one-simbol\r\n\r\nwhat-where=> one-simbol\r\n;=> where-is-it\r\n\r\nwhat-where=> (resolve 'one-simbol)\r\n;=> #'what-where/one-simbol  ;looks like namespace-qualified symbol\r\n\t\t\t\t\t\t ;but it's just a characteristic of symbol evaluation\r\n\r\nwhat-where=> `one-symbol   ;back tick\r\n;=> what-where/one-symbol\r\n```\r\n\r\n# Functions\r\n\r\nFunctions are a first-class type in Clojure. They can be used the same as any value (stored in Vars, held in collections, passed as arguments and returned as a result of other functions).\r\n\r\n```clj\r\nlet( [x] (+ x 1))\r\n```\r\n\r\nWe can’t actually evaluate this program, because there’s no value for `x` yet. It could be `1`, or `4`, or `1453`. We say that `x` is _unbound_, because it has no binding to a particular value. This is the nature of the __function__: an expression with unbound symbols.\r\n\r\nFunction definition:\r\n\r\n```clj\r\n(fn [x] (+ x 1))\r\n;=> #<user$eval1487$fn__1488 user$eval1487$fn__1488@6b7d28db>\r\n```\r\n\r\nNamed function definition:\r\n\r\n```clj\r\n(let [twice (fn [x] (* 2 x))]\r\n   (+ (twice 1)\r\n   (twice 3)))\r\n;=> 8\r\n```\r\n\r\n`let` bindings describe a similar relationship, but with a specific set of values for those arguments. `let` is evaluated immediately, whereas `fn` is evaluated later, when bindings are provided.\r\n\r\n## Vars\r\n\r\nOnce a `let` is defined, there’s no way to change it. If we want to redefine symbols for everyone, even code that we didn’t write, we need a new construct, a mutable variable.\r\n\r\n```clj\r\n(def cats 5)\r\n;=> #'user/cats\r\n\r\n(type #'user/cats)\r\n;=> clojure.lang.Var\r\n\r\ncats\r\n;=> 5\r\n```\r\n\r\n`def` defines a type of value we haven’t seen before: a _Var_. _Vars_, like symbols, are references to other values. When evaluated, a _Var_ is replaced by its corresponding value.  \r\n\r\n`def` also binds the symbol `cats` (and its globally qualified equivalent `user/cats`) to that _Var_.  \r\n\r\nThe symbol `inc` points to the _Var_ `#'inc`, which in turn points to the function `#<core$inc clojure.core$inc@16bc0b3c>`.  \r\n\r\nWe can see the intermediate Var with `resolve`:\r\n\r\n```clj\r\n'inc     ;symbol\r\n;=> inc\r\n\r\n(resolve 'inc)\r\n;=> #'clojure.core/inc    ;variable\r\n\r\n(eval 'inc)\r\n;=> #<core$inc clojure.core$inc@d6206b5>  ;value\r\n```\r\n\r\nWhy those two levels of indirection? Unlike with symbol, we can change the meaning of a Var for everyone, globally, at any time.  \r\n\r\nVars don't require a value. Instead we can just declare them and, by doing so, defer the binding of value.\r\n\r\n```clj\r\n(def y)\r\n;=> #'user/y\r\n\r\n;; if we try to use it:\r\ny\r\n\r\n;=> java.lang.IllegalStateException: Var user/y is unbound\r\n```\r\n\r\n## Named functions\r\n\r\n```clj\r\n(def half \r\n  (fn [number] (/ number 2)))\r\n;=> #'user/half\r\n\r\n(half 8)\r\n;=> 4\r\n```\r\n\r\nCreating a function and binding it to a variable is so common that it has its own form: `defn`, which is a _macro_ that is short for `def fn`:\r\n\r\n```clj\r\n(defn half [number] (/ number 2))\r\n;=> #'user/half\r\n\r\n(half 8)\r\n;=> 4\r\n```\r\n\r\nFunctions don’t have to take an argument. We’ve seen functions which take zero arguments, like `(+)`:\r\n\r\n```clj\r\n(defn half [] 1/2)\r\n;=> #'user/half\r\n```\r\n\r\nBut if we try to use our earlier form with one argument, Clojure complains that the *arity* (the number of arguments to a function) is incorrect:\r\n\r\n```clj\r\n(half 8)\r\n\r\n;=> ArityException Wrong number of args (1) passed to: user$half\r\n;=> clojure.lang.AFn.throwArity (AFn.java:437)\r\n```\r\n\r\nTo handle multiple arities, functions have an alternate form, instead of an argument vector and a body, one provides a series of lists, each of which starts with an argument vector, followed by the body:\r\n\r\n```clj\r\n(defn half\r\n   ([] 1/2)\r\n   ([x] (/ x 2)))\r\n;=> #'user/half\r\n\r\n(half)\r\n;=> 1/2\r\n\r\n(half 8)\r\n;=> 4\r\n```\r\n\r\nMultiple arguments work just like you expect. Just specify an argument vector of two, or three, or however many arguments the function takes.  \r\nSome functions can take any number of arguments. For that, Clojure provides `&`, which slurps up all remaining arguments as a list:\r\n\r\n```clj\r\n(defn vargs [x y & more-args]\r\n   {:x x\r\n\t:y y\r\n\t:more more-args})\r\n;=> #'user/vargs\r\n\r\n(vargs 1 2)\r\n;=> {:x 1, :y 2, :more nil}\r\n\r\n(vargs 1 2 3 4 5)\r\n;=> {:x 1, :y 2, :more (3 4 5)}\r\n```\r\n\r\n`x` and `y` are mandatory, though there don’t have to be any remaining arguments.  \r\n\r\nTo keep track of what arguments a function takes, why the function exists, and what it does, we usually include a **docstring**. Docstrings help fill in the missing context around functions, to explain their assumptions, context, and purpose to the world:\r\n\r\n```clj\r\n(defn launch\r\n   \"Launches a spacecraft into the given orbit by initiating a\r\n\tcontrolled on-axis burn. Does not automatically stage, but\r\n\tdoes vector thrust, if the craft supports it.\"\r\n   [craft target-orbit]\r\n   \"OK, we don't know how to control spacecraft yet.\")\r\n;=> #'user/launch\r\n```\r\n\r\nDocstrings are used to automatically generate documentation for a Clojure programs, but you can also access them from the **REPL** (The `user=>` prompt refers to the top-level namespace of the default REPL):\r\n\r\n```clj\r\n(doc launch)\r\n;=> -------------------------\r\n;=> user/launch\r\n;=> ([craft target-orbit])\r\n;=>   Launches a spacecraft into the given orbit by initiating a\r\n;=>    controlled on-axis burn. Does not automatically stage, but\r\n;=>    does vector thrust, if the craft supports it.\r\n;=> nil\r\n```\r\n\r\n`doc` tells us the full name of the function, the arguments it accepts, and its docstring. This information comes from the `launch` Var’s metadata, and is saved there by `defn`. We can inspect metadata directly with the `meta` function:\r\n\r\n```clj\r\n(meta #'launch)\r\n;=> {:arglists ([craft target-orbit]), :ns #<Namespace user>, :name launch, :column 1,\r\n;=> :doc \"Launches a spacecraft into the given orbit by initiating a\\n   controlled \r\n;=> on-axis burn. Does not automatically stage, but\\n   does vector thrust, if the \r\n;=> craft supports it.\", :line 1, :file \"/tmp/form-init523009510157887861.clj\"}\r\n```\r\n\r\nThere’s some other juicy information in there, like the file the function was defined in and which line and column it started at, but that’s not particularly useful since we’re in the _REPL_, not a file. However, this does hint at a way to answer our motivating question: how does the `type` function work?\r\n\r\n## Blocks\r\n\r\nWhen you have a series or block of expressions that need to be treated as one, use `do`. All the expressions will be evaluated, but only the last one will be returned:\r\n\r\n```clj\r\n(do\r\n   6\r\n   (+ 5 4)\r\n   3)\r\n;=> 3\r\n```\r\n\r\nThe expressions `6` and `(+ 5 4)` are perfectly legal. The addition in `(+ 5 4)` is even done, but the value is thrown away, only the final expression `3` is returned\r\n\r\n## How does `type` work?\r\n\r\n`type`, like all functions, is a kind of object with its own unique type:\r\n\r\n```clj\r\ntype\r\n;=> #<core$type clojure.core$type@2761df2a>\r\n\r\n(type type)\r\n;=> clojure.core$type\r\n```\r\n\r\nThis tells us that `type` is a particular instance, at memory address `39bda9b9`, of the type `clojure.core$type`. \r\n`clojure.core` is a namespace which defines the fundamentals of the Clojure language, and `$type` tells us that it’s named type in that namespace. None of this is particularly helpful, though. Maybe we can find out more about the `clojure.core$type` by asking what its supertypes are:\r\n\r\n```clj\r\n(supers (type type))\r\n;=> #{java.io.Serializable java.lang.Runnable clojure.lang.AFunction \r\n;=> clojure.lang.IMeta clojure.lang.AFn java.lang.Object clojure.lang.IObj \r\n;=> java.util.Comparator clojure.lang.Fn java.util.concurrent.Callable \r\n;=> clojure.lang.IFn}\r\n```\r\n\r\nThis is a set of all the types that include `type`. We say that `type` is an instance of `clojure.lang.AFunction`, or that it implements or extends `java.util.concurrent.Callable`, and so on. Since it’s a member of `clojure.lang.IMeta` it has metadata, and since it’s a member of `clojure.lang.AFn`, it’s a function. Just to double check, let’s confirm that `type` is indeed a function:\r\n\r\n```clj\r\n(fn? type)\r\n;=> true\r\n```\r\n\r\n`type` can take a single argument, which it calls `x`. If it has `:type` metadata, that’s what it returns. Otherwise, it returns the class of `x`. Let’s take a deeper look at `type`’s metadata for more clues:\r\n\r\n```clj\r\n(doc type)\r\n;=> -------------------------\r\n;=> clojure.core/type\r\n;=> ([x])\r\n;=>   Returns the :type metadata of x, or its Class if none\r\n;=> nil\r\n```\r\n\r\nThis function was first added to Clojure in version `1.0`, and is defined in the file `clojure/core.clj`, on line `3109`:\r\n\r\n```clj\r\n(meta #'type)\r\n;=> {:ns #<Namespace clojure.core>, :name type, :arglists ([x]), :column 1, \r\n;=> :added \"1.0\", :static true, :doc \"Returns the :type metadata of x, or its Class \r\n;=> if none\", :line 3109, :file \"clojure/core.clj\"}\r\n```\r\n\r\nWe could go dig up the Clojure source code and read its definition there, or we could ask Clojure to do it for us. Aha! Here, at last, is how `type` works. It’s a function which takes a single argument `x`, and returns either `:type` from its metadata, or `(class x)`.\r\n\r\n```clj\r\n(source type)\r\n;=> (defn type \r\n;=>   \"Returns the :type metadata of x, or its Class if none\"\r\n;=>   {:added \"1.0\"\r\n;=>    :static true}\r\n;=>   [x]\r\n;=>   (or (get (meta x) :type) (class x)))\r\n;=> nil\r\n```\r\n\r\n# Sequences\r\n\r\nA **sequential** collection is one that holds a series of values without reordering them.\r\n\r\nA **sequence** is a sequential collection that represents a series of values that may or may not exist yet (may have concrete values, may be lazy or empty). Few composite types are actually _sequences_, though several such as vectors are _sequential_. All an object needs to do to be a sequence is to support two core functions, `first` and `rest`\r\n\r\nA **seq** is a simple API for navigating collections which consists of two functions, `first` and `rest`\r\n\r\nIf two sequentials have the same values in the same order, `=` will return `true` for them, even if their concrete types are different:\r\n\r\n```clj\r\n(= [1 2 3] '(1 2 3))\r\n;=> true\r\n```\r\n\r\nConversely, even if two collections have the same values in the same order, if one is a sequential collection and the other isn't, `=` will return `false`:\r\n\r\n```clj\r\n(= [1 2 3] #{1 2 3})\r\n;=> false\r\n```\r\n\r\nIf the collection is empty, `seq` always returns `nil` and never an empty sequence (that goes for all other functions that return a `seq`, e.g. `next`).\r\n\r\n> Clojure classifies each composite data type into 3 partitions: _sequentials_, _maps_ and _sets_. Everything that implements `java.util.List` is included in the sequential partition. Generally things that fall into other two partitions include set or map in their name\r\n\r\nEvery collection type provides at least one kind of `seq` object for walking through its elements\r\n\r\n## Recursion\r\n\r\n`cons`, makes a list beginning with the first argument, followed by all the elements in the second argument:\r\n\r\n```clj\r\n(cons 1 [2 3 4])\r\n;=> (1 2 3 4)\r\n```\r\n\r\nProblem of incrementing all elements of a vector:\r\n\r\n```clj\r\n(defn inc-first [nums]\r\n   (if (first nums)\r\n\t ; If there's a first num, build a new list with cons\r\n\t (cons (inc (first nums))\r\n\t\t   (rest nums))\r\n\t ; If there's no first num, return an empty list\r\n\t (list)))\r\n;=> #'user/inc-first\r\n\r\n(inc-first [])\r\n;=> ()\r\n\r\n(inc-first [1 2 3])\r\n;=> (2 2 3)\r\n```\r\n\r\nWhat if we called our function on `rest`?\r\n\r\n```clj\r\n(defn inc-all [nums]\r\n   (if (first nums)\r\n\t (cons (inc (first nums))\r\n\t\t   (inc-all (rest nums)))\r\n\t (list)))\r\n;=> #'user/inc-all\r\n\r\n(inc-all [1 2 3 4])\r\n;=> (2 3 4 5)\r\n```\r\n\r\nThis technique is called _recursion_, and it is a fundamental principle in working with collections, sequences, trees, graphs or any problem which has small parts linked together. There are two key elements in a recursive program:\r\n - Some part of the problem which has a known solution\r\n - A relationship which connects one part of the problem to the next\r\n\r\nIncrementing the elements of an empty list returns the empty list. This is our **base case**, the ground to build on. Our **inductive case**, also called the _recurrence relation_, is how we broke the problem up into incrementing the first number in the sequence, and incrementing all the numbers in the rest of the sequence. The `if` expression bound these two cases together into a single function, a function defined in terms of itself.\r\nLet’s parameterize our `inc-all` function to use any transformation of its elements:\r\n\r\n```clj\r\n(defn transform-all [f xs]\r\n   (if (first xs)\r\n\t (cons (f (first xs))\r\n\t\t   (transform-all f (rest xs)))\r\n\t (list)))\r\n;=> #'user/transform-all\r\n\r\n(transform-all inc [1 2 3 4])\r\n;=> (2 3 4 5)\r\n```\r\n\r\n## Loop\r\n\r\nWhen using recursion, you sometimes want to loop back not to the top of the function, but to somewhere inside the function body.  \r\nThe `loop` acts exactly like `let` but provides a target for `recur` to jump to:\r\n\r\n```clj\r\n(defn sum-down-from [initial-x]\r\n   (loop [sum 0, x initial-x]\r\n\t (if (pos? x)\r\n\t   (recur (+ sum x) (dec x))\r\n\t   sum)))\r\n;=> #'user/sum-down-from\r\n```\r\n\r\nUpon entering the `loop`, the locals `sum` and `x` are initialized (like in `let`). A `recur` always loops back to the closest enclosing `loop` or `fn`. The `loop` locals are rebound to the values given in `recur`.  \r\n`recur` works only from the tail position.  \r\n\r\n`keyword` transforms a string to keyword:\r\n\r\n```clj\r\n(transform-all keyword [\"aa\" \"bb\" \"cc\"])\r\n;=> (:aa :bb :cc)\r\n```\r\n\r\nTo wrap every element in a list:\r\n\r\n```clj\r\n(transform-all list [\"aa\" \"bb\" \"cc\"])\r\n;=> ((\"aa\") (\"bb\") (\"cc\"))\r\n```\r\n\r\nWe basically implemented `map` function:\r\n\r\n```clj\r\n(map inc [1 2 3 4])\r\n;=> (2 3 4 5)\r\n```\r\n\r\nThe function `map` relates one sequence to another. The type `map` relates keys to values. There is a deep symmetry between the two: maps are usually sparse, and the relationships between keys and values may be arbitrarily complex. The `map` function, on the other hand, usually expresses the same type of relationship, applied to a series of elements in a fixed order.\r\n\r\nClojure has a _special form_ called `recur` that's specifically used for tail recursion:\r\n\r\n```clj\r\n(defn print-down-from [x]\r\n   (when (pos? x)  ;return when x is no longer positive\r\n\t (println x)\r\n\t (recur (dec x))))\r\n;=> #'user/print-down-from\r\n\r\n(print-down-from 5)\r\n;=> 5\r\n;=> 4\r\n;=> 3\r\n;=> 2\r\n;=> 1\r\n;=> nil\r\n```\r\n\r\n> `when` is same as `if`, except it doesn't have the `else` part and it requires an implicit `do` in order to perform side-effects\r\n\r\nThis is nearly identical to how you’d structure a while loop in an imperative language.One significant difference is that the value of `x` isn’t decremented somewhere in the body of the loop. Instead, a new value is calculated as a parameter to `recur`, which immediately does two things: rebinds `x` to the new value and returns control to the top of `print-down-from`.  \r\nIf the function has multiple arguments, the `recur` call must as well, just as if you were calling the function by name instead of using the `recur` special form. And just as with a function call, the expressions in the `recur` are evaluated in order first and only then bound to the function arguments simultaneously.\r\n\r\n## Building Sequences\r\n\r\nWe can use recursion to expand a single value into a sequence of values, each related by some function. For instance (`pos?` returns `true` if `num` is greater than zero, else `false`):\r\n\r\n```clj\r\n(defn expand [f x count]\r\n   (if (pos? count)\r\n\t (cons x (expand f (f x) (dec count)))))\r\n;=> #'user/expand\r\n\r\n(expand inc 0 10)\r\n;=> (0 1 2 3 4 5 6 7 8 9)\r\n```\r\n\r\nOur base case is `x` itself, followed by the sequence beginning with `(f x)`. That sequence in turn expands to `(f (f x))`, and then to `(f (f (f x)))`, and so on. Each time we call `expand`, we count down by one using `dec`. Once the `count` is zero, `if` returns `nil`, and evaluation stops.\r\n\r\nClojure has a more general form of this function, called `iterate`:\r\n\r\n```clj\r\n(take 10 (iterate inc 0))\r\n;=> (0 1 2 3 4 5 6 7 8 9)\r\n```\r\n\r\nSince this sequence is infinitely long, we’re using `take` to select only the first 10 elements. We can construct more complex sequences by using more complex functions:\r\n\r\n```clj\r\n(take 10 (iterate (fn [x] (if (odd? x) (+ 1 x) (/ x 2))) 10))\r\n;=> (10 5 6 3 4 2 1 2 1 2)\r\n```\r\n\r\n`repeat` constructs a sequence where every element is the same:\r\n\r\n```clj\r\n(take 10 (repeat \"a\"))\r\n;=> (\"a\" \"a\" \"a\" \"a\" \"a\" \"a\" \"a\" \"a\" \"a\" \"a\")\r\n\r\n(repeat 5 \"b\")\r\n;=> (\"b\" \"b\" \"b\" \"b\" \"b\")\r\n```\r\n\r\n`repeatedly` simply calls a function `(f)` to generate an infinite sequence of values, over and over again, without any relationship between elements. For an infinite sequence of random numbers:\r\n\r\n```clj\r\n(rand)\r\n;=> 0.6934524557647231\r\n\r\n(rand)\r\n;=> 0.1355414232605504\r\n\r\n(take 3 (repeatedly rand))\r\n;=> (0.18806021884865332 0.5231673860825672 0.38244349544358525)\r\n```\r\n\r\n`range` generates a sequence of numbers between two points. \r\n`(range n)` gives `n` successive integers starting at 0. \r\n`(range n m)` returns integers from `n` to `m-1`. \r\n`(range n m step)` returns integers from `n` to `m`, separated by `step`:\r\n\r\n```clj\r\n(range 5)\r\n;=> (0 1 2 3 4)\r\n\r\n(range 5 8)\r\n;=> (5 6 7)\r\n\r\n(range 5 25 5)\r\n;=> (5 10 15 20)\r\n```\r\n\r\n`cycle` returns an infinite lazy sequence of repetitions of the items in a collection:\r\n\r\n```clj\r\n(take 6 (cycle (range 5 50 5)))\r\n;=> (5 10 15 20 25 30)\r\n```\r\n\r\n## Transforming Sequences\r\n\r\n`map` applies a function to each element, but it has a few more tricks up its sleeve:\r\n\r\n```clj\r\n(map (fn [n vehicle] (str \"I've got \" n \" \" vehicle \"s\"))\r\n   [0 200 9]\r\n   [\"car\" \"train\" \"kiteboard\"])\r\n;=> (\"I've got 0 cars\" \"I've got 200 trains\" \"I've got 9 kiteboards\")\r\n```\r\n\r\nIf given multiple sequences, `map` calls its function with one element from each sequence in turn. So the first value will be `(f 0 \"car\")`, the second `(f 200 \"train\")`, and so on. Like a zipper, map folds together corresponding elements from multiple collections. To sum three vectors, column-wise:\r\n\r\n```clj\r\n(map + [1 2 3]\r\n\t\t[4 5 6]\r\n\t\t[3 2 1])\r\n;=> (8 9 10)\r\n```\r\n\r\nIf one sequence is bigger than another, `map` stops at the end of the smaller one. We can exploit this to combine finite and infinite sequences. For example, to number the elements in a vector:\r\n\r\n```clj\r\n(map (fn [index element] (str index \". \" element))\r\n\t  (iterate inc 0)\r\n\t  [\"erlang\" \"scala\" \"haskell\"])\r\n;=> (\"0. erlang\" \"1. scala\" \"2. haskell\")\r\n```\r\n\r\nTransforming elements together with their indices is so common that Clojure has a special function for it: `map-indexed`:\r\n\r\n```clj\r\n(map-indexed (fn [index element] (str index \". \" element))\r\n\t\t\t  [\"erlang\" \"scala\" \"haskell\"])\r\n;=> (\"0. erlang\" \"1. scala\" \"2. haskell\")\r\n```\r\n\r\nYou can also tack one sequence onto the end of another, like so:\r\n\r\n```clj\r\n(concat [1 2 3] [:a :b :c] [4 5 6])\r\n;=> (1 2 3 :a :b :c 4 5 6)\r\n```\r\n\r\nAnother way to combine two sequences is to riffle them together, using `interleave`:\r\n\r\n```clj\r\n(interleave [:a :b :c] [1 2 3])\r\n;=> (:a 1 :b 2 :c 3)\r\n```\r\n\r\nAnd if you want to insert a specific element between each successive pair in a sequence, try `interpose`:\r\n\r\n```clj\r\n(interpose :and [1 2 3 4])\r\n;=> (1 :and 2 :and 3 :and 4)\r\n```\r\n\r\nTo reverse a sequence, use ... you guessed it, `reverse`:\r\n\r\n```clj\r\n(reverse [1 2 3])\r\n;=> (3 2 1)\r\n\r\n(reverse \"woolf\")\r\n;=> (\\f \\l \\o \\o \\w)  ;not a string\r\n```\r\n\r\nStrings are sequences too! Each element of a string is a character, written `\\f`. You can rejoin those characters into a string with `apply str`:\r\n\r\n```clj\r\n(apply str (reverse \"woolf\"))\r\n;=> \"floow\"\r\n```\r\n\r\n…and break strings up into sequences of chars with `seq`:\r\n\r\n```clj\r\n(seq \"sato\")\r\n;=> (\\s \\a \\t \\o)\r\n```\r\n\r\nTo randomize the order of a sequence, use `shuffle`:\r\n\r\n```clj\r\n(shuffle [1 2 3 4 5])\r\n;=> [4 3 5 1 2]\r\n\r\n(apply str (shuffle (seq \"abracadabra\")))\r\n;=> \"raradbabaac\"\r\n```\r\n\r\n## Subsequences\r\n\r\n`take` selects the first `n` elements\r\n`drop` removes the first `n` elements\r\n`take-last` and `drop-last` operate on the last `n` elements:\r\n\r\n```clj\r\n(take 3 (range 10))\r\n;=> (0 1 2)\r\n\r\n(drop 3 (range 10))\r\n;=> (3 4 5 6 7 8 9)\r\n\r\n(take-last 3 (range 10))\r\n;=> (7 8 9)\r\n\r\n(drop-last 3 (range 10))\r\n;=> (0 1 2 3 4 5 6)\r\n```\r\n\r\n`take-while` and `drop-while` work just like `take` and `drop`, but use a function to decide when to stop:\r\n\r\n```clj\r\n(take-while pos? [3 2 1 0 -1 -2 10])\r\n;=> (3 2 1)\r\n```\r\n\r\nIn general, one can cut a sequence in twain by using `split-at` with a particular index. There’s also `split-with`, which uses a function to decide when to cut:\r\n\r\n```clj\r\n(split-at 4 (range 10))\r\n;=> [(0 1 2 3) (4 5 6 7 8 9)]\r\n\r\n(split-with number? [1 2 3 :mark 4 5 6 :mark 7])\r\n;=> [(1 2 3) (:mark 4 5 6 :mark 7)]\r\n```\r\n\r\nNotice that because indexes start at zero, sequence functions tend to have predictable number of elements.`(split-at 4)` yields four elements in the first collection, and ensures the second collection begins at index four. `(range 10)` has ten elements, corresponding to the first ten indices in a sequence. `(range 3 5)` has two (as in `5 - 3 = 2`) elements. These choices simplify the definition of recursive functions as well.\r\nWe can select particular elements from a sequence by applying a function. To pull up all positive numbers in a list, use `filter`:\r\n\r\n```clj\r\n(filter pos? [1 5 -4 -7 3 0])\r\n;=> (1 5 3)\r\n```\r\n\r\n`filter` looks at each element in turn, and includes it in the resulting sequence only if `(f element)` returns a _truthy_ value. Its complement is `remove`, which only includes those elements where `(f element)` is `false` or `nil`:\r\n\r\n```clj\r\n(remove string? [1 \"tur\" :apple])\r\n;=> (1 :apple)\r\n```\r\n\r\nOne can group a sequence into chunks using `partition`, `partition-all`, or `partition-by`. For instance, one might group alternating values into pairs like this:\r\n\r\n```clj\r\n(partition 2 [:cats 5 :bats 27 :crocs 0])\r\n;=> ((:cats 5) (:bats 27) (:crocs 0))\r\n```\r\n\r\nSeparate a series of numbers into negative and positive subsequences:\r\n\r\n```clj\r\n(partition-by neg? [1 2 3 2 1 -1 -2 -3 -2 -1 1 2])\r\n;=> ((1 2 3 2 1) (-1 -2 -3 -2 -1) (1 2))\r\n```\r\n\r\n`partition-all n collection` may include partitions with fewer than `n` items at the end:\r\n\r\n```clj\r\n(partition-all 3 [1 2 -5 3 2 1 -1 -2 -3 -2 -1 1 2])\r\n;=> ((1 2 -5) (3 2 1) (-1 -2 -3) ( -2 -1 1) ( 2))\r\n```\r\n\r\nwhile `partition` may not:\r\n\r\n```clj\r\n(partition 3 [1 2 -5 3 2 1 -1 -2 -3 -2 -1 1 2])\r\n;=> ((1 2 -5) (3 2 1) (-1 -2 -3) (-2 -1 1))\r\n```\r\n\r\n### Collapsing subsequences\r\n\r\nAfter transforming a sequence, we often want to collapse it in some way, in order to derive some smaller value. For instance, we might want the number of times each element appears in a sequence:\r\n\r\n```clj\r\n(frequencies [:meow :mrrrow :meow :meow])\r\n;=> {:meow 3, :mrrrow 1}\r\n```\r\n\r\nTo group elements by some function:\r\n\r\n```clj\r\n(pprint (group-by :first [{:first \"Li\"    :last \"Zhou\"}\r\n\t\t\t\t\t\t   {:first \"Sarah\" :last \"Lee\"}\r\n\t\t\t\t\t\t   {:first \"Sarah\" :last \"Dunn\"}\r\n\t\t\t\t\t\t   {:first \"Li\"    :last \"O'Toole\"}]))\r\n;=> {\"Li\" [{:last \"Zhou\", :first \"Li\"} {:last \"O'Toole\", :first \"Li\"}],\r\n;=>  \"Sarah\" [{:last \"Lee\", :first \"Sarah\"} {:last \"Dunn\", :first \"Sarah\"}]}\r\n```\r\n\r\nHere we’ve taken a sequence of people with first and last names, and used the `:first` keyword (which can act as a function!) to look up those first names. `group-by` used that function to produce a map of first names to lists of people, kind of like an index.\r\nIn general, we want to combine elements together in some way, using a function. Where `map` treated each element independently, reducing a sequence requires that we bring some information along. The most general way to collapse a sequence is `reduce`:\r\n\r\n```clj\r\n(doc reduce)\r\n;=> -------------------------\r\n;=> clojure.core/reduce\r\n;=> ([f coll] [f val coll])\r\n;=>   f should be a function of 2 arguments. If val is not supplied,\r\n;=>   returns the result of applying f to the first 2 items in coll, then\r\n;=>   applying f to that result and the 3rd item, etc. If coll contains no\r\n;=>   items, f must accept no arguments as well, and reduce returns the\r\n;=>   result of calling f with no arguments.  If coll has only 1 item, it\r\n;=>   is returned and f is not called.  If val is supplied, returns the\r\n;=>   result of applying f to val and the first item in coll, then\r\n;=>   applying f to that result and the 2nd item, etc. If coll contains no\r\n;=>   items, returns val and f is not called.\r\n\r\n(reduce + [1 2 3 4])\r\n;=> 10\r\n\r\n(reduce + 1 [1 2 3 4])\r\n;=> 11\r\n```\r\n\r\nTo see the reducing process in action, we can use `reductions`, which returns a sequence of all the intermediate states:\r\n\r\n```clj\r\n(reductions + [1 2 3 4])\r\n;=> (1 3 6 10)\r\n```\r\n\r\nOftentimes we include a default state to start with. For instance, we could start with an empty set, and add each element to it as we go along:\r\n\r\n```clj\r\n(reduce conj #{} [:a :b :b :b :a :c])\r\n;=> #{:a :c :b}\r\n```\r\n\r\nReducing elements into a collection has its own name: `into`. We can `conj [key value]` vectors into a map, for instance, or build up a list:\r\n\r\n```clj\r\n(into {} [[:a 2] [:b 3]])\r\n;=> {:a 2, :b 3}\r\n\r\n(into (list) [1 2 3 4])\r\n;=> (4 3 2 1)\r\n```\r\n\r\nBecause **elements added to a list appear at the beginning**, not the end, this expression **reverses the sequence**. Vectors `conj` onto the end, so to emit the elements in order, using reduce, we might try:\r\n\r\n```clj\r\n(reduce conj [] [1 2 3 4 5])\r\n;=> [1 2 3 4 5]\r\n```\r\n\r\nRemember?\r\n\r\n```clj\r\n(conj [-1 0] [1 2 3 4 5])\r\n;=> [-1 0 [1 2 3 4 5]]               ; not [-1 0 1 2 3 4 5]\r\n```\r\n\r\nThis looks like a `map` function. All that’s missing is some kind of transformation applied to each element:\r\n\r\n```clj\r\n(defn my-map [f coll]\r\n   (reduce (fn [output element]\r\n\t\t\t (conj output (f element)))\r\n\t\t   []\r\n\t\t   coll))\r\n;=> #'user/my-map\r\n\r\n(my-map inc [1 2 3 4])\r\n;=> [2 3 4 5]\r\n```\r\n\r\nSo `map` is just a special kind of `reduce`. What about, say, `take-while`?\r\n\r\n```clj\r\n(defn my-take-while [f coll]\r\n   (reduce (fn [out elem]\r\n\t\t\t (if (f elem)\r\n\t\t\t   (conj out elem)\r\n\t\t\t   (reduced out)))\r\n\t\t   []\r\n\t\t   coll))\r\n;=> #'user/my-take-while\r\n```\r\n\r\nWe’re using a special function here, `reduced`, to indicate that we’ve completed our reduction early and can skip the rest of the sequence.\r\n\r\n```clj\r\n(my-take-while pos? [2 1 0 -1 0 1 2])\r\n;=> [2 1]\r\n```\r\n\r\nMost of Clojure’s **sequence functions are lazy**. For instance, we can increment every number from zero to infinity:\r\n\r\n```clj\r\n(def infseq (map inc (iterate inc 0)))\r\n;=> #'user/infseq\r\n\r\n(realized? infseq)\r\n;=> false\r\n```\r\n\r\nThat function returned immediately. Because it hasn’t done any work yet, we say the sequence is unrealized. It doesn’t increment any numbers at all until we ask for them:\r\n\r\n```clj\r\n(take 10 infseq)\r\n;=> (1 2 3 4 5 6 7 8 9 10)\r\n\r\n(realized? infseq)\r\n;=> true\r\n```\r\n\r\n**Lazy sequences also remember their contents, once evaluated, for faster access.**\r\n\r\nFind the sum of the products of consecutive pairs of the first 1000 odd integers.\r\n\r\n```clj\r\n(reduce +\r\n\t\t (take 1000\r\n\t\t\t   (map (fn [pair] (* (first pair) (second pair)))\r\n\t\t\t\t\t(partition 2 1\r\n\t\t\t\t\t  (filter odd?\r\n\t\t\t\t\t\t(iterate inc 0))))))\r\n;=> 1335333000\r\n```\r\n\r\n__Homework:__\r\n\r\n1. Write a function to find out if a string is a palindrome.\r\n\r\n```clj\r\n(defn palindrome? [word] \r\n  (== 0 (compare word (apply str (reverse word)))))\r\n```\r\n\r\n2. Find the number of `c`s in `“abracadabra”`.\r\n\r\n```clj\r\n(defn occurs-count [c word]\r\n  (get (frequencies (seq word)) c 0))\r\n```\r\n\r\n3. Write your own version of `filter`.\r\n\r\n```clj\r\n;=> TBD\r\n```\r\n\r\n# Java interop\r\n\r\nClojure is _symbiotic_ with its host, providing its rich and powerful features, while Java provides an object model, libraries and runtime support.\r\n\r\nClojure strings are Java `String`s, numbers are `Number`s, collections implement `Collection`, fns implement `Callable` and `Runnable`, ...\r\n\r\nCore abstractions, such as `seq`, are Java interfaces (`ISeq`).  \r\nClojure `seq` library works on Java `Iterable`s, `String`s and arrays.  \r\nIt is possible to implement and extend Java interfaces and classes.  \r\n\r\n**Accessing static class members**\r\n\r\n... is trivial:\r\n\r\n```clj\r\njava.util.Locale/JAPAN\r\n;=> #<Locale ja_JP>\r\n```\r\n\r\nIdiomatic Clojure prefers that you access static class members using a syntax like accessing a namespace-qualified Var:\r\n\r\n```clj\r\n(Math/sqrt 9)  ; the same as (java.lang.Math/sqrt 9)\r\n;=> 3.0\r\n```\r\n\r\n**Creating Java class instances**\r\n\r\n```clj\r\n(new java.util.HashMap {\"foo\" 42 \"bar\" 8 \"baz\" \"beep boop\"})\r\n;=> {\"baz\" \"beep boop\", \"foo\" 42, \"bar\" 8}\r\n\r\n;;idiomatic:\r\n(java.util.HashMap. {\"foo\" 42 \"bar\" 8 \"baz\" \"beep boop\"})   ;dot = constructor call\r\n;=> {\"baz\" \"beep boop\", \"foo\" 42, \"bar\" 8}\r\n```\r\n\r\n**Accessing Java instance members with the dot operator**\r\n\r\nTo access instance properties, precede the property or method name with a dot:\r\n\r\n```clj\r\n(.x (java.awt.Point. 10 20))  ;create a new Point and access its member x\r\n;=> 10\r\n```\r\n\r\nTo access instance methods, the dot form allows an additional argument to be passed to the method:\r\n\r\n```clj\r\n(.divide (java.math.BigDecimal. \"42\") 2K)\r\n;=> 21M\r\n\r\n; what's this M for?\r\n(type 2M)\r\n;=> java.math.BigDecimal\r\n```\r\n\r\n**Setting Java instance properties**\r\n\r\nIn the absence of mutator methods, in the form of `setX`, Java instance properties can be set using `set!` function:\r\n\r\n```clj\r\n(let [origin (java.awt.Point. 0 0)]\r\n  (set! (.x origin) 15)     ;(set! <instance_member_access> <value>)\r\n  (str origin))\r\n;=> \"java.awt.Point[x=15,y=0]\"\r\n```\r\n\r\n**The `..` macro**\r\n\r\nFor now, think of a macro as a convenience function. We'll meet them [later](#macros).  \r\nIn Java, it's a common practice to chain together a sequence of method calls, e.g:\r\n\r\n```java\r\nnew java.util.Date().toString().endsWith(\"2014\")  ;java\r\n```\r\n\r\n... which is equivalent to this Clojure expression:\r\n\r\n```clj\r\n(.endsWith (.toString (java.util.Date.)) \"2014\")\r\n;=> true\r\n```\r\n\r\nWell, anyone would agree that this is rather difficult to read.  \r\nTo remedy this, Clojure provides us with `..` macro:\r\n\r\n```clj\r\n(.. (java.util.Date.) toString (endsWith \"2014\"))\r\n;=> true\r\n```\r\n\r\n**The `doto` macro**\r\n\r\nIn Java, it's also common to initialize a fresh instance by calling a set of mutators:\r\n\r\n```java\r\njava.util.HashMap props = new java.util.HashMap();  /* java */\r\nprops.put(\"HOME\", \"/home/myself\");\r\nprops.put(\"SRC\",  \"src\");\r\nprops.put(\"BIN\",  \"classes\");\r\n```\r\n\r\nThat's obviously overly verbose, but it can be streamlined using the `doto` macro:\r\n\r\n```clj\r\n(doto (java.util.HashMap.)       ;do to HashMap all these things\r\n  (.put \"HOME\" \"/home/myself\")\r\n  (.put \"SRC\"  \"src\")\r\n  (.put \"BIN\"  \"classes\"))\r\n;=> {\"HOME\" \"/home/myself\", \"BIN\" \"classes\", \"SRC\" \"src\"}\r\n```\r\n\r\n# Exceptions\r\n\r\nLike Java, Clojure also provides `try`, `catch`, `finally` and `throw` forms:\r\n\r\n```clj\r\n(throw (Exception. \"Thrown\"))\r\n\r\n;=> Exception Thrown  user/eval1201 (form-init8547084957850583270.clj:1)\r\n\r\n(defn throw-catch [f]\r\n  [(try\r\n\t(f)\r\n\t(catch ArithmeticException e \"You did not? Not by zero! Noooooooooooo...\")\r\n\t(catch Exception e (str \"You blew it \" (.getMessage e)))\r\n\t(finally (println \"returning... \")))])\r\n;=> #'user/throw-catch\r\n\r\n(throw-catch #(/ 10 5))\r\n;=> returning... \r\n;=> [2]\r\n\r\n(throw-catch #(/ 10 0))\r\n;=> returning... \r\n;=> [\"You did not? Not by zero! Noooooooooooo...\"]\r\n\r\n(throw-catch #(throw (Exception. \"dawg!\")))\r\n;=> returning... \r\n;=> [\"You blew it dawg!\"]\r\n```\r\n\r\n> Clojure doesn't adhere to checked exception requirements, like Java does.\r\n\r\n> When an exception is thrown in REPL, the result is stored in a Var named `*e`, which allows you to get more detail about the expression, such as the stack trace:\r\n\r\n```clj\r\n(.printStackTrace *e)\r\n```\r\n\r\n# Namespaces\r\n\r\nProvide a way to bundle related functions, macros and values.\r\n\r\n**Creating namespaces using `ns` macro**\r\n\r\n```clj\r\n(ns mbo.core.strings)\r\n;=> nil\r\n;=> mbo.core.strings=>    ;from now on, this is our REPL prompt\r\n```\r\n\r\nThere's also a _Var_ `*ns*`, which holds the value of the current namespace.  \r\nWe know from before that any _Var_ created will be a member of the current namespace.\r\n\r\n```clj\r\nmbo.core.strings=> (defn report-ns [] (str \"The current namespace is \" *ns*))\r\n;=> #'mbo.core.strings/report-ns\r\n\r\nmbo.core.strings=> (report-ns)\r\n;=> \"The current namespace is mbo.core.strings\"\r\n\r\nmbo.core.strings=> (defn sing [] (println \"Marjane Marjane, Marjane Marjane, ...\"))\r\n;=> #'mbo.core.strings/sing\r\n\r\nmbo.core.strings=> sing    ;Clojure looks it up in the current namespace\r\n;=> #<strings$sing mbo.core.strings$sing@3987b05>\r\n\r\nmbo.core.strings=> (ns mbo.core.compat)   ;create another namespace\r\n;=> nil\r\n\r\nmbo.core.compat=> (report-ns)             ;try invoking function from another ns\r\n\r\nmbo.core.compat=> CompilerException java.lang.RuntimeException: \r\n;=> Unable to resolve symbol: report-ns in this context, \r\n;=> compiling:(/tmp/form-init8547084957850583270.clj:1:1)\r\n\r\nmbo.core.compat=> (mbo.core.strings/report-ns) ;fully qualified name works as expected\r\n;=> \"The current namespace is mbo.core.compat\"\r\n```\r\n\r\n> referring to a namespace symbol using fully qualified name will only work for namespaces created locally or those previously loaded. Read on, it'll become clear...\r\n\r\n**Using `:require` directive to load other namespaces**\r\n\r\n```clj\r\nmbo.core.compat=> (ns mbo.core.set\r\n\t\t\t\t\t(:require clojure.set))\r\n;=> nil\r\n;=> mbo.core.set=>  ;changed to new ns\r\n\r\nmbo.core.set=> (clojure.set/intersection #{1 2 3} #{2 3 4})\r\n;=> #{2 3}\r\n\r\nmbo.core.set=> (intersection #{1 2 3} #{2 3 4})  ;invoke a clojure.set function directly\r\n\r\n;=> CompilerException java.lang.RuntimeException: Unable to resolve symbol: \r\n;=> intersection in this context, compiling:(/tmp/form-init8547084957850583270.clj:1:1)\r\n```\r\n\r\nThis construct indicates that we want the `clojure.set` namespace loaded, but we don't want the mappings of that namespace's symbols to `mbo.core.set` functions.\r\n\r\nWe can also use `:as` directive to create an additional alias to `clojure.set`:\r\n\r\n```clj\r\nmbo.core.set=> (ns mbo.core.set-alias\r\n\t\t\t\t\t#_=>   (:require [clojure.set :as s]))\r\n;=> nil\r\n\r\nmbo.core.set-alias=> (s/intersection #{1 2 3} #{2 3 4})\r\n;=> #{2 3}\r\n```\r\n\r\nThe qualified namespace form (e.g. `clojure.set`) looks the same as a call to a _static class method_. The difference is that a _namespace symbol_ can only be used as a qualifier, whereas a _class symbol_ can also be referenced independently:\r\n\r\n```clj\r\nmbo.core.set-alias=> clojure.set\r\n\r\n;=> mbo.core.set-alias=> CompilerException java.lang.ClassNotFoundException: \r\n;=> clojure.set, compiling:(/tmp/form-init8547084957850583270.clj:1:691) \r\n\r\nmbo.core.set-alias=> java.lang.Object\r\n;=> java.lang.Object\r\n```\r\n\r\n> That vagaries of namespace mappings from symbols to _Vars_, both qualified and unqualified, have the potential for confusion between _class names_ and _static methods_. In the beginning, that is. The differences will begin to feel natural as we progress (at least that's what _The joy of Clojure_ book promises :)\r\n> One of the Clojure idioms is to use `my.Class` and `my.ns` for naming classes and namespaces, to help eliminate potential confusion.\r\n\r\n**Loading and creating mappings with `:use`**\r\n\r\n`:use`, unlike `:require`, maps Vars in another namespace to names in your own. That is typically used to avoid calling each function or macro with the qualifying namespace symbol:\r\n\r\n```clj\r\nmbo.core.set-alias=> (ns mbo.test\r\n\t\t\t\t#_=>   (:use [clojure.string :only [capitalize]]))\r\n;=> nil\r\n\r\nmbo.test=> (map capitalize [\"one\" \"two\"])\r\n;=> (\"One\" \"Two\")\r\n;=> mbo.test=>\r\n```\r\n\r\n`:only` is used to indicate that only the listed functions should be mapped in the new namespace (good practice). The `:exclude` directive does the opposite.  \r\n`:use`, besides creating mappings, implicitly invokes `:require`.\r\n\r\n> the idiomatic strategy for avoiding conflicts is to use `:require` with `:as` to create a namespace alias\r\n\r\n**Create mappings with `:refer`**\r\n\r\n`:refer` is a directive that works almost exactly like `:use`, except that it only creates mappings for libraries that have already been loaded (by being previously defined, by being one of Clojure's core namespaces or by having been explicitly loaded using `:require`).\r\n\r\n**Loading Java classes with `:import`**\r\n\r\n```clj\r\nmbo.test=> (ns mbo.java\r\n\t  #_=>   (:import [java.util HashMap]\r\n\t  #_=>            [java.util.concurrent.atomic.AtomicLong]))\r\n;=> nil\r\n\r\nmbo.java=> (HashMap. {\"happy?\" true})\r\n;=> {\"happy?\" true}\r\n```\r\n\r\n> Any classes in the `java.lang` package are implicitly imported when namespaces are created\r\n\r\n**`nil` punning**\r\n\r\nSince, in Clojure, everything except `nil` and `false` is `true`, empty collections evaluate to `true` in boolean context. We need a way to test whether a collection is empty or not.  \r\n\r\nThis is where _nil punning_ comes in:\r\n\r\n```clj\r\n(seq [1 2 3])\r\n;=> (1 2 3)\r\n\r\n(seq [])\r\n;=> nil\r\n```\r\n\r\n`seq` function returns a sequence view of a collection or `nil` if the collection is empty.\r\n\r\n```clj\r\n(defn print-seq [s]\r\n  (when (seq s)\r\n\t(prn (first s))     ;prn prints each object in a newline (to the output stream)\r\n\t(recur (rest s))))\r\n\r\n(print-seq [1 2])\r\n;=> 1\r\n;=> 2\r\n;=> nil\r\n```\r\n\r\nThe use of `seq` as a terminating condition is the idiomatic way of testing whether a sequence is empty\r\n\r\n# Destructuring\r\n\r\nAllows you to place a collection of names in a binding form where normally you'd put just a single name.  \r\n\r\n> Destructuring is loosely related to _pattern matching_ (found in Haskell or [Scala](https://github.com/mbonaci/scala#case-classes-and-pattern-matching)), but much more limited in scope. For full-featured pattern matching in Clojure use [matchure](http://github.com/dcolthorp/matchure).\r\n\r\nPerhaps the simplest form of destructuring is picking apart a sequential thing (e.g. a vector or a list), giving each item a name:\r\n\r\n```clj\r\n(let [[fname mname lname] [\"Frane\" \"Luka\" \"Bonaci\"]]\r\n  (str lname \", \" fname \" \" mname))\r\n;=> \"Bonaci, Frane Luka\"\r\n\r\n;; although this is syntactically correct, it isn't factually accurate\r\n;; my month and a half old twins are named Frane and Luka :)\r\n;; what can I say, my wife is a hero (that's what everybody's telling me these days)\r\n;; hmmm, I wonder why?\r\n```\r\n\r\nThis was a so called _positional destructuring_, which, as you might expect, doesn't work on maps and sets, because they are not logically aligned sequentially. But it does work on `java.util.regex.Matcher` and anything implementing `CharSequence` and `java.util.RandomAccess` interfaces.  \r\n  \r\n**Destructuring with a vector**\r\n  \r\nWe can also use an ampersand in a destructuring vector to indicate that any remaining values of the input should be collected into a (possibly lazy) `seq`:\r\n\r\n```clj\r\n(let [[a b c & more] (range 10)]\r\n  (println \"a b c are: \" a b c)\r\n  (println \"the rest is: \" more))\r\n;=> a b c are:  0 1 2\r\n;=> the rest is:  (3 4 5 6 7 8 9)\r\n```\r\n\r\nA useful feature of vector destructuring is `:as`, which is used to bind a local to the entire collection. It must be placed at the end, even after the `&` local (if it exists):\r\n\r\n```clj\r\n(let [range-vec (vec (range 10))\r\n  [a b c & more :as all] range-vec]\r\n  (println \"a b c are: \" a b c)\r\n  (println \"the rest is \" more)\r\n  (println \"all is: \" all))\r\n;=> a b c are:  0 1 2\r\n;=> the rest is  (3 4 5 6 7 8 9)\r\n;=> all is:  [0 1 2 3 4 5 6 7 8 9]\r\n```\r\n\r\n> Notice the difference between `&` and `:as`. While `:all` produces a vector, `&` results with a `seq`.\r\n\r\n**Destructuring with a map**\r\n\r\n```clj\r\n(def full-name-map\r\n  {:fname \"Frane\" :mname \"Luka\" :lname \"Bonaci\"})\r\n\r\n(let [{fname :fname, mname :mname, lname :lname} full-name-map]\r\n  (str lname \", \" fname \" \" mname))\r\n;=> \"Bonaci, Frane Luka\"\r\n```\r\n\r\nHere, the `:keys` feature might come in handy:\r\n\r\n```clj\r\n(let [{:keys [fname mname lname]} full-name-map]\r\n  (str lname \", \" fname \" \" mname))\r\n;=> \"Bonaci, Frane Luka\"\r\n```\r\n\r\nBy using `:keys`, we're telling Clojure that the next form will be a vector of names that it should convert to keywords (e.g. `:fname`), in order to look up their values in the input map.  \r\n\r\nWe can do the same thing with `:strs` and `:syms`, except that the first one would look for string keys in the map (e.g. `\"fname\"`), and the latter one would indicate we're looking for symbol keys.  \r\n\r\nSometimes you'll want to get the keys that you didn't name individually by any of the previously described methods. In that case, we use `:as`, which works just like it does with vector:\r\n\r\n```clj\r\n(let [{fname :fname, :as whole-name} full-name-map]\r\n  whole-name)\r\n;=> {:mname \"Luka\", :lname \"Bonaci\", :fname \"Frane\"}\r\n```\r\n\r\nIf the destructuring map looks up a key that's not in the source map, it's bound to `nil`, but it's possible to provide different defaults with `:or`:\r\n\r\n```clj\r\n(let [{:keys [title fname mname lname], :or {title \"Mr.\"}} full-name-map]\r\n  (println title fname mname lname))\r\n;=> Mr. Frane Luka Bonaci\r\n```\r\n\r\n**Associative destructuring**\r\n\r\nUsing a map to define bindings isn't limited to maps, we can destructure a vector by providing a map declaring the local name as vector indices:\r\n\r\n```clj\r\n(let [{first-thing 0, last-thing 3} [1 2 3 4]]\r\n  [first-thing last-thing])\r\n;=> [1 4]\r\n```\r\n\r\n**Destructuring in function parameters**\r\n\r\nAll previous examples use `let` to do destructuring, but exactly the same features are available in function parameters. Each function parameter can destructure a map or a sequence:\r\n\r\n```clj\r\n(defn print-last-name [{:keys [lname]}]\r\n  (println lname))\r\n\r\n(print-last-name full-name-map)\r\n;=> Bonaci\r\n```\r\n\r\n> When function arguments include an ampersand, that's not destructuring, but part of support for multiple function bodies, each with its own number of parameters.\r\n\r\n**Destructuring versus accessor methods**\r\n\r\nIt's idiomatic in Clojure to build your application objects by composing maps and vectors, instead of using multiple objects with getters and setters, as Java does.\r\nThis makes destructuring natural and straightforward. So anytime you find yourself calling `nth` on the same collection multiple times, or looking up constants in a map, or using `first` or `next`, consider using destructuring instead.\r\n\r\n# Composite data types\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n[![Bitdeli Badge](https://d2weczhvl823v0.cloudfront.net/mbonaci/clojure/trend.png)](https://bitdeli.com/free \"Bitdeli Badge\")\r\n\r\n","google":"UA-48000266-1","note":"Don't delete this file! It's used internally to help with page regeneration."}